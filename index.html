<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#0a0e27">
    <meta name="description" content="××©×—×§ ××™×–×•×Ÿ ×¤×™×–×™×§×œ×™ ××ª×§×“× - × ×”×œ ××¨×›×– ××¡×” ×•××–×Ÿ ××ª ×”××’×“×œ">
    <title>××’×“×œ ×”××™×–×•×Ÿ | Tower Balance</title>
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/png" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect fill='%23ff6b35' width='100' height='100'/><rect fill='%23f7931e' x='20' y='60' width='60' height='30'/></svg>">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@700;900&family=Rajdhani:wght@400;600;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        :root {
            --primary: #ff6b35;
            --secondary: #f7931e;
            --accent: #00d9ff;
            --bg-dark: #0a0e27;
            --bg-mid: #1a1f3a;
            --text: #ffffff;
            --text-dim: #8892b0;
            --success: #00ffa3;
            --danger: #ff3366;
            --shadow: rgba(0, 0, 0, 0.4);
        }

        body {
            font-family: 'Rajdhani', sans-serif;
            background: linear-gradient(135deg, var(--bg-dark) 0%, #0f1333 50%, var(--bg-mid) 100%);
            color: var(--text);
            overflow: hidden;
            touch-action: none;
            height: 100vh;
            position: relative;
        }

        /* Animated Background */
        body::before {
            content: '';
            position: absolute;
            width: 200%;
            height: 200%;
            background-image: 
                radial-gradient(circle at 20% 50%, rgba(255, 107, 53, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(0, 217, 255, 0.1) 0%, transparent 50%);
            animation: bgShift 20s ease-in-out infinite;
            z-index: 0;
        }

        @keyframes bgShift {
            0%, 100% { transform: translate(0, 0); }
            50% { transform: translate(-10%, -10%); }
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            cursor: grab;
        }

        #gameCanvas:active {
            cursor: grabbing;
        }

        /* HUD Container */
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            z-index: 10;
            pointer-events: none;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 20px;
            flex-wrap: wrap;
        }

        .hud-panel {
            background: rgba(26, 31, 58, 0.85);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 107, 53, 0.3);
            border-radius: 15px;
            padding: 15px 20px;
            box-shadow: 0 8px 32px var(--shadow);
            pointer-events: auto;
        }

        .score-panel {
            animation: slideInTop 0.5s ease-out;
        }

        @keyframes slideInTop {
            from {
                transform: translateY(-100px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .score-label {
            font-size: 14px;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 5px;
        }

        .score-value {
            font-family: 'Orbitron', monospace;
            font-size: 36px;
            font-weight: 900;
            color: var(--accent);
            text-shadow: 0 0 20px rgba(0, 217, 255, 0.5);
            line-height: 1;
        }

        .info-panel {
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: 180px;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 15px;
        }

        .info-label {
            font-size: 14px;
            color: var(--text-dim);
            text-transform: uppercase;
        }

        .info-value {
            font-family: 'Orbitron', monospace;
            font-size: 18px;
            font-weight: 700;
            color: var(--text);
        }

        /* Timer Bar */
        .timer-container {
            position: relative;
            height: 8px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            overflow: hidden;
            margin-top: 10px;
        }

        .timer-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--success) 0%, var(--secondary) 50%, var(--danger) 100%);
            border-radius: 10px;
            transition: width 0.1s linear;
            box-shadow: 0 0 10px rgba(255, 107, 53, 0.6);
        }

        /* Stability Meter */
        .stability-container {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            max-width: 90vw;
            z-index: 10;
            pointer-events: none;
        }

        .stability-label {
            text-align: center;
            font-size: 12px;
            color: var(--text-dim);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .stability-bar-container {
            position: relative;
            height: 20px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 12px;
            border: 2px solid rgba(255, 107, 53, 0.4);
            overflow: hidden;
        }

        .stability-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--danger), var(--secondary), var(--success), var(--secondary), var(--danger));
            transition: all 0.3s ease;
            position: relative;
        }

        .stability-marker {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 100%;
            background: white;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
        }

        /* Control Buttons */
        .controls {
            position: absolute;
            bottom: 80px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            z-index: 10;
        }

        .control-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 2px solid var(--accent);
            background: rgba(26, 31, 58, 0.9);
            backdrop-filter: blur(10px);
            color: var(--accent);
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 20px var(--shadow);
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
        }

        .control-btn:hover {
            background: rgba(0, 217, 255, 0.2);
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(0, 217, 255, 0.5);
        }

        .control-btn:active {
            transform: scale(0.95);
        }

        .control-btn.active {
            background: var(--accent);
            color: var(--bg-dark);
        }

        /* Next Character Preview */
        .next-character {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(26, 31, 58, 0.85);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 107, 53, 0.3);
            border-radius: 15px;
            padding: 15px 25px;
            display: flex;
            align-items: center;
            gap: 15px;
            box-shadow: 0 8px 32px var(--shadow);
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.05); }
        }

        .next-label {
            font-size: 14px;
            color: var(--text-dim);
            text-transform: uppercase;
        }

        .next-icon {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            background: rgba(255, 107, 53, 0.2);
        }

        .next-type {
            font-family: 'Orbitron', monospace;
            font-size: 16px;
            font-weight: 700;
            color: var(--accent);
        }

        /* Start Screen */
        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(10, 14, 39, 0.95) 0%, rgba(15, 19, 51, 0.95) 100%);
            backdrop-filter: blur(20px);
            z-index: 100;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            animation: fadeIn 0.5s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .game-title {
            font-family: 'Orbitron', monospace;
            font-size: 48px;
            font-weight: 900;
            text-align: center;
            margin-bottom: 20px;
            background: linear-gradient(135deg, var(--primary), var(--secondary), var(--accent));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 40px rgba(255, 107, 53, 0.3);
            animation: titleGlow 3s ease-in-out infinite;
        }

        @keyframes titleGlow {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.3); }
        }

        .game-subtitle {
            font-size: 20px;
            color: var(--text-dim);
            text-align: center;
            margin-bottom: 50px;
            max-width: 400px;
        }

        .difficulty-selector {
            display: flex;
            gap: 15px;
            margin-bottom: 40px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .difficulty-btn {
            padding: 15px 30px;
            border-radius: 12px;
            border: 2px solid var(--accent);
            background: transparent;
            color: var(--text);
            font-family: 'Rajdhani', sans-serif;
            font-size: 18px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .difficulty-btn:hover {
            background: rgba(0, 217, 255, 0.1);
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 217, 255, 0.3);
        }

        .difficulty-btn.selected {
            background: var(--accent);
            color: var(--bg-dark);
        }

        .start-btn {
            padding: 20px 60px;
            border-radius: 50px;
            border: none;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: var(--text);
            font-family: 'Orbitron', monospace;
            font-size: 24px;
            font-weight: 900;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            box-shadow: 0 8px 30px rgba(255, 107, 53, 0.4);
            letter-spacing: 2px;
        }

        .start-btn:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 12px 40px rgba(255, 107, 53, 0.6);
        }

        .start-btn:active {
            transform: translateY(-1px) scale(1.02);
        }

        /* Game Over Screen */
        #gameOverScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(10, 14, 39, 0.95) 0%, rgba(15, 19, 51, 0.95) 100%);
            backdrop-filter: blur(20px);
            z-index: 100;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            animation: fadeIn 0.5s ease-out;
        }

        .game-over-title {
            font-family: 'Orbitron', monospace;
            font-size: 56px;
            font-weight: 900;
            color: var(--danger);
            margin-bottom: 30px;
            text-shadow: 0 0 30px rgba(255, 51, 102, 0.5);
            animation: shake 0.5s ease-out;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px) rotate(-2deg); }
            75% { transform: translateX(10px) rotate(2deg); }
        }

        .final-stats {
            background: rgba(26, 31, 58, 0.8);
            border: 2px solid rgba(255, 107, 53, 0.3);
            border-radius: 20px;
            padding: 30px 40px;
            margin-bottom: 40px;
            min-width: 300px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 15px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stat-row:last-child {
            border-bottom: none;
        }

        .stat-label {
            font-size: 18px;
            color: var(--text-dim);
        }

        .stat-value {
            font-family: 'Orbitron', monospace;
            font-size: 24px;
            font-weight: 700;
            color: var(--accent);
        }

        .restart-btn {
            padding: 18px 50px;
            border-radius: 50px;
            border: none;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: var(--text);
            font-family: 'Orbitron', monospace;
            font-size: 20px;
            font-weight: 900;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            box-shadow: 0 8px 30px rgba(255, 107, 53, 0.4);
        }

        .restart-btn:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 12px 40px rgba(255, 107, 53, 0.6);
        }

        /* Responsive */
        @media (max-width: 768px) {
            .game-title {
                font-size: 36px;
            }

            .score-value {
                font-size: 28px;
            }

            .controls {
                bottom: 60px;
                right: 10px;
            }

            .control-btn {
                width: 50px;
                height: 50px;
                font-size: 20px;
            }
        }

        /* Loading Animation */
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: var(--accent);
            animation: loadingPulse 1.5s ease-in-out infinite;
        }

        @keyframes loadingPulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }

        /* Notification */
        .notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(26, 31, 58, 0.95);
            backdrop-filter: blur(10px);
            border: 2px solid var(--danger);
            border-radius: 15px;
            padding: 20px 40px;
            font-size: 24px;
            font-weight: 700;
            color: var(--danger);
            z-index: 200;
            animation: notificationPop 0.5s ease-out;
            pointer-events: none;
        }

        @keyframes notificationPop {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.1); }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
    </style>
</head>
<body>
    <!-- Start Screen -->
    <div id="startScreen">
        <h1 class="game-title">ğŸ—ï¸ ××’×“×œ ×”××™×–×•×Ÿ</h1>
        <p class="game-subtitle">× ×”×œ ××¨×›×– ××¡×”, ×©××•×¨ ×¢×œ ××™×–×•×Ÿ ×•×”×’×¢ ×œ×©×™× ×—×“×©!</p>
        
        <div class="difficulty-selector">
            <button class="difficulty-btn" data-difficulty="easy">×§×œ</button>
            <button class="difficulty-btn selected" data-difficulty="medium">×‘×™× ×•× ×™</button>
            <button class="difficulty-btn" data-difficulty="hard">×§×©×”</button>
            <button class="difficulty-btn" data-difficulty="expert">××•××—×”</button>
        </div>
        
        <button class="start-btn" id="startBtn">×”×ª×—×œ ××©×—×§</button>
    </div>

    <!-- Game Over Screen -->
    <div id="gameOverScreen">
        <h1 class="game-over-title">×”××’×“×œ ×§×¨×¡!</h1>
        
        <div class="final-stats">
            <div class="stat-row">
                <span class="stat-label">× ×™×§×•×“</span>
                <span class="stat-value" id="finalScore">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">×ª×™×™×¨×™×</span>
                <span class="stat-value" id="finalTourists">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">×–×•×•×™×ª ××§×¡×™××œ×™×ª</span>
                <span class="stat-value" id="finalAngle">0Â°</span>
            </div>
        </div>
        
        <button class="restart-btn" id="restartBtn">×©×—×§ ×©×•×‘</button>
    </div>

    <!-- Game Canvas -->
    <canvas id="gameCanvas"></canvas>

    <!-- HUD -->
    <div id="hud">
        <div class="hud-top">
            <div class="hud-panel score-panel">
                <div class="score-label">× ×™×§×•×“</div>
                <div class="score-value" id="scoreDisplay">0</div>
            </div>
            
            <div class="hud-panel info-panel">
                <div class="info-row">
                    <span class="info-label">×ª×•×¨</span>
                    <span class="info-value" id="turnDisplay">1</span>
                </div>
                <div class="info-row">
                    <span class="info-label">×ª×™×™×¨×™×</span>
                    <span class="info-value" id="touristDisplay">0</span>
                </div>
                <div class="timer-container" id="timerContainer" style="display: none;">
                    <div class="timer-bar" id="timerBar"></div>
                </div>
            </div>
        </div>

        <div class="next-character">
            <span class="next-label">×”×‘×:</span>
            <div class="next-icon" id="nextIcon">ğŸ‘¤</div>
            <span class="next-type" id="nextType">×¨×’×™×œ</span>
        </div>
    </div>

    <!-- Stability Meter -->
    <div class="stability-container">
        <div class="stability-label">×™×¦×™×‘×•×ª</div>
        <div class="stability-bar-container">
            <div class="stability-bar" id="stabilityBar">
                <div class="stability-marker"></div>
            </div>
        </div>
    </div>

    <!-- Controls -->
    <div class="controls">
        <button class="control-btn" id="topViewBtn" title="××‘×˜ ××œ××¢×œ×”">â¬‡ï¸</button>
        <button class="control-btn" id="horizonBtn" title="××‘×˜ ××•×¤×§">â†”ï¸</button>
        <button class="control-btn" id="resetViewBtn" title="××™×¤×•×¡ ××¦×œ××”">ğŸ¯</button>
    </div>

    <script>
        // ============================================
        // GAME CONFIGURATION
        // ============================================
        const CONFIG = {
            physics: {
                gravity: 9.81,
                maxAngle: 45, // degrees
                damping: 0.95,
                restitution: 0.15,
                friction: 0.7,
                slideFrictionAngle: 15, // degrees
            },
            tower: {
                baseWidth: 80,
                floorHeight: 60,
                floorCount: 8,
                maxPerFloor: 4,
            },
            characters: {
                types: {
                    standard: { mass: 1, size: 20, icon: 'ğŸ§', color: '#4a9eff' },
                    heavy: { mass: 2, size: 25, icon: 'ğŸ‹ï¸', color: '#ff4a4a' },
                    child: { mass: 0.5, size: 15, icon: 'ğŸ‘¶', color: '#ffd700' },
                },
            },
            difficulty: {
                easy: { timer: false, wind: false, friction: 0.8 },
                medium: { timer: true, timerDuration: 15, wind: false, friction: 0.7 },
                hard: { timer: true, timerDuration: 10, wind: true, windInterval: 10, friction: 0.6 },
                expert: { timer: true, timerDuration: 8, wind: true, windInterval: 5, friction: 0.5 },
            },
            camera: {
                zoom: 1,
                offsetX: 0,
                offsetY: 0,
                mode: 'default', // default, top, horizon
            },
        };

        // ============================================
        // GAME STATE
        // ============================================
        class GameState {
            constructor() {
                this.score = 0;
                this.turn = 1;
                this.tourists = 0;
                this.maxAngle = 0;
                this.difficulty = 'medium';
                this.gameOver = false;
                this.paused = false;
            }

            reset() {
                this.score = 0;
                this.turn = 1;
                this.tourists = 0;
                this.maxAngle = 0;
                this.gameOver = false;
                this.paused = false;
            }
        }

        // ============================================
        // PHYSICS ENGINE
        // ============================================
        class PhysicsEngine {
            constructor(config) {
                this.config = config;
                this.angle = 0; // radians
                this.angularVelocity = 0;
                this.angularAcceleration = 0;
                this.momentOfInertia = 1000;
                this.windForce = { x: 0, y: 0 };
            }

            calculateCenterOfMass(characters) {
                if (characters.length === 0) return { x: 0, y: 0 };

                let totalMass = 0;
                let comX = 0;
                let comY = 0;

                characters.forEach(char => {
                    totalMass += char.mass;
                    comX += char.mass * char.x;
                    comY += char.mass * char.y;
                });

                return {
                    x: comX / totalMass,
                    y: comY / totalMass,
                    totalMass
                };
            }

            applyTorque(com, pivotX) {
                const r = com.x - pivotX;
                const force = com.totalMass * this.config.gravity;
                const torque = r * force;
                
                // Add wind torque
                const windTorque = this.windForce.x * 0.1;
                
                this.angularAcceleration = (torque + windTorque) / this.momentOfInertia;
            }

            update(dt, characters, pivotX) {
                const com = this.calculateCenterOfMass(characters);
                this.applyTorque(com, pivotX);

                // Update angular velocity and angle
                this.angularVelocity += this.angularAcceleration * dt;
                this.angularVelocity *= this.config.damping;
                this.angle += this.angularVelocity * dt;

                // Check for collapse
                const maxAngleRad = (this.config.maxAngle * Math.PI) / 180;
                if (Math.abs(this.angle) > maxAngleRad) {
                    return true; // Collapse
                }

                return false;
            }

            applyWind() {
                this.windForce.x = (Math.random() - 0.5) * 2;
            }

            getAngleDegrees() {
                return (this.angle * 180) / Math.PI;
            }

            reset() {
                this.angle = 0;
                this.angularVelocity = 0;
                this.angularAcceleration = 0;
                this.windForce = { x: 0, y: 0 };
            }
        }

        // ============================================
        // CHARACTER CLASS
        // ============================================
        class Character {
            constructor(type, x, y, floor) {
                const charType = CONFIG.characters.types[type];
                this.type = type;
                this.mass = charType.mass;
                this.size = charType.size;
                this.icon = charType.icon;
                this.color = charType.color;
                this.x = x;
                this.y = y;
                this.floor = floor;
                this.isSliding = false;
                this.velocity = { x: 0, y: 0 };
            }

            draw(ctx, towerAngle) {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // Draw character body
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw icon
                ctx.font = `${this.size * 1.2}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.icon, 0, 0);
                
                ctx.restore();
            }

            checkSliding(towerAngle) {
                const criticalAngle = (CONFIG.physics.slideFrictionAngle * Math.PI) / 180;
                if (Math.abs(towerAngle) > criticalAngle) {
                    this.isSliding = true;
                    const slideAccel = CONFIG.physics.gravity * Math.sin(towerAngle);
                    this.velocity.x += slideAccel * 0.016; // dt
                }
            }

            update(dt) {
                if (this.isSliding) {
                    this.x += this.velocity.x * dt;
                    this.velocity.x *= CONFIG.physics.friction;
                }
            }
        }

        // ============================================
        // TOWER CLASS
        // ============================================
        class Tower {
            constructor(config, canvas) {
                this.config = config;
                this.canvas = canvas;
                this.baseX = canvas.width / 2;
                this.baseY = canvas.height - 100;
                this.floors = [];
                this.initFloors();
            }

            initFloors() {
                for (let i = 0; i < this.config.tower.floorCount; i++) {
                    this.floors.push({
                        y: this.baseY - (i + 1) * this.config.tower.floorHeight,
                        characters: [],
                    });
                }
            }

            draw(ctx, angle) {
                ctx.save();
                ctx.translate(this.baseX, this.baseY);
                ctx.rotate(angle);

                // Draw base
                ctx.fillStyle = '#ff6b35';
                ctx.fillRect(-this.config.tower.baseWidth / 2, 0, this.config.tower.baseWidth, 20);

                // Draw floors
                this.floors.forEach((floor, i) => {
                    const floorY = -(i + 1) * this.config.tower.floorHeight;
                    
                    // Floor platform
                    ctx.fillStyle = '#f7931e';
                    ctx.fillRect(-this.config.tower.baseWidth / 2, floorY, this.config.tower.baseWidth, 10);
                    
                    // Floor outline
                    ctx.strokeStyle = '#00d9ff';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(-this.config.tower.baseWidth / 2, floorY, this.config.tower.baseWidth, 10);
                });

                // Draw support pillars
                ctx.strokeStyle = '#8892b0';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(-this.config.tower.baseWidth / 2 + 5, 0);
                ctx.lineTo(-this.config.tower.baseWidth / 2 + 5, -this.config.tower.floorCount * this.config.tower.floorHeight);
                ctx.moveTo(this.config.tower.baseWidth / 2 - 5, 0);
                ctx.lineTo(this.config.tower.baseWidth / 2 - 5, -this.config.tower.floorCount * this.config.tower.floorHeight);
                ctx.stroke();

                ctx.restore();
            }

            addCharacter(character, floorIndex) {
                if (floorIndex < 0 || floorIndex >= this.floors.length) return false;
                
                const floor = this.floors[floorIndex];
                if (floor.characters.length >= this.config.tower.maxPerFloor) {
                    // Push out oldest character
                    floor.characters.shift();
                }
                
                floor.characters.push(character);
                return true;
            }

            getAllCharacters() {
                const allChars = [];
                this.floors.forEach(floor => {
                    allChars.push(...floor.characters);
                });
                return allChars;
            }

            reset() {
                this.floors.forEach(floor => {
                    floor.characters = [];
                });
            }
        }

        // ============================================
        // GAME CLASS
        // ============================================
        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.resizeCanvas();
                
                this.state = new GameState();
                this.physics = new PhysicsEngine(CONFIG.physics);
                this.tower = new Tower(CONFIG, this.canvas);
                
                this.currentCharacter = null;
                this.nextCharacterType = this.getRandomCharacterType();
                this.dragCharacter = null;
                this.ghostPreview = null;
                
                this.timer = 0;
                this.maxTimer = 15;
                this.windTimer = 0;
                this.windInterval = 10;
                
                this.cameraMode = 'default';
                this.cameraZoom = 1;
                
                this.setupEventListeners();
                this.updateHUD();
                
                window.addEventListener('resize', () => this.resizeCanvas());
            }

            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                
                // Update tower position
                if (this.tower) {
                    this.tower.baseX = this.canvas.width / 2;
                    this.tower.baseY = this.canvas.height - 100;
                }
            }

            setupEventListeners() {
                // Mouse events
                this.canvas.addEventListener('mousedown', (e) => this.handleStart(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.handleEnd(e));
                
                // Touch events
                this.canvas.addEventListener('touchstart', (e) => this.handleStart(e.touches[0]));
                this.canvas.addEventListener('touchmove', (e) => this.handleMove(e.touches[0]));
                this.canvas.addEventListener('touchend', (e) => this.handleEnd(e));
                
                // Camera controls
                document.getElementById('topViewBtn').addEventListener('click', () => this.setCameraMode('top'));
                document.getElementById('horizonBtn').addEventListener('click', () => this.setCameraMode('horizon'));
                document.getElementById('resetViewBtn').addEventListener('click', () => this.setCameraMode('default'));
            }

            handleStart(e) {
                if (this.state.gameOver || this.dragCharacter) return;
                
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // Create new character at cursor
                this.dragCharacter = new Character(
                    this.nextCharacterType,
                    x,
                    y,
                    -1
                );
                
                this.currentCharacter = this.dragCharacter;
            }

            handleMove(e) {
                if (!this.dragCharacter) return;
                
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                this.dragCharacter.x = x;
                this.dragCharacter.y = y;
                
                // Update ghost preview
                this.updateGhostPreview(x, y);
            }

            handleEnd(e) {
                if (!this.dragCharacter) return;
                
                // Check if valid placement
                const floorIndex = this.getFloorAtPosition(this.dragCharacter.y);
                if (floorIndex >= 0) {
                    // Adjust position relative to tower
                    this.dragCharacter.x = this.dragCharacter.x - this.tower.baseX;
                    this.dragCharacter.y = this.tower.floors[floorIndex].y;
                    this.dragCharacter.floor = floorIndex;
                    
                    // Add to tower
                    this.tower.addCharacter(this.dragCharacter, floorIndex);
                    
                    // Update game state
                    this.state.tourists++;
                    this.state.score += Math.floor(this.dragCharacter.mass * 10);
                    this.state.turn++;
                    
                    // Reset timer
                    this.timer = 0;
                    
                    // Generate next character
                    this.nextCharacterType = this.getRandomCharacterType();
                    this.updateNextCharacterDisplay();
                    
                    this.updateHUD();
                }
                
                this.dragCharacter = null;
                this.ghostPreview = null;
            }

            updateGhostPreview(x, y) {
                const floorIndex = this.getFloorAtPosition(y);
                if (floorIndex >= 0) {
                    const floor = this.tower.floors[floorIndex];
                    const isValid = floor.characters.length < CONFIG.tower.maxPerFloor;
                    
                    this.ghostPreview = {
                        x,
                        y: floor.y + this.tower.baseY,
                        valid: isValid,
                    };
                } else {
                    this.ghostPreview = null;
                }
            }

            getFloorAtPosition(y) {
                for (let i = 0; i < this.tower.floors.length; i++) {
                    const floorY = this.tower.floors[i].y + this.tower.baseY;
                    if (Math.abs(y - floorY) < 40) {
                        return i;
                    }
                }
                return -1;
            }

            getRandomCharacterType() {
                const rand = Math.random();
                if (this.state.turn % 5 === 0) return 'heavy';
                if (rand < 0.2) return 'child';
                return 'standard';
            }

            updateNextCharacterDisplay() {
                const charType = CONFIG.characters.types[this.nextCharacterType];
                document.getElementById('nextIcon').textContent = charType.icon;
                
                let typeName = '×¨×’×™×œ';
                if (this.nextCharacterType === 'heavy') typeName = '×›×‘×“';
                if (this.nextCharacterType === 'child') typeName = '×™×œ×“';
                document.getElementById('nextType').textContent = typeName;
            }

            setCameraMode(mode) {
                this.cameraMode = mode;
                
                document.querySelectorAll('.control-btn').forEach(btn => btn.classList.remove('active'));
                
                if (mode === 'top') {
                    document.getElementById('topViewBtn').classList.add('active');
                } else if (mode === 'horizon') {
                    document.getElementById('horizonBtn').classList.add('active');
                }
            }

            update(dt) {
                if (this.state.gameOver || this.state.paused) return;
                
                // Update timer
                const diffConfig = CONFIG.difficulty[this.state.difficulty];
                if (diffConfig.timer) {
                    this.timer += dt;
                    if (this.timer >= diffConfig.timerDuration) {
                        this.forceSpawn();
                        this.timer = 0;
                    }
                    this.updateTimerDisplay();
                }
                
                // Update wind
                if (diffConfig.wind) {
                    this.windTimer += dt;
                    if (this.windTimer >= diffConfig.windInterval) {
                        this.physics.applyWind();
                        this.windTimer = 0;
                    }
                }
                
                // Update physics
                const characters = this.tower.getAllCharacters();
                const collapsed = this.physics.update(dt, characters, this.tower.baseX);
                
                if (collapsed) {
                    this.gameOver();
                    return;
                }
                
                // Update max angle
                const currentAngle = Math.abs(this.physics.getAngleDegrees());
                if (currentAngle > this.state.maxAngle) {
                    this.state.maxAngle = currentAngle;
                }
                
                // Check sliding
                characters.forEach(char => {
                    char.checkSliding(this.physics.angle);
                    char.update(dt);
                });
                
                this.updateStabilityDisplay();
            }

            forceSpawn() {
                // Spawn character at random position
                const charType = this.getRandomCharacterType();
                const randomFloor = Math.floor(Math.random() * this.tower.floors.length);
                const randomX = (Math.random() - 0.5) * CONFIG.tower.baseWidth * 0.8;
                
                const char = new Character(charType, randomX, this.tower.floors[randomFloor].y, randomFloor);
                this.tower.addCharacter(char, randomFloor);
                
                this.state.tourists++;
                this.state.turn++;
                
                this.nextCharacterType = this.getRandomCharacterType();
                this.updateNextCharacterDisplay();
                this.updateHUD();
            }

            draw() {
                // Clear canvas
                this.ctx.fillStyle = 'transparent';
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.ctx.save();
                
                // Apply camera transformations
                if (this.cameraMode === 'top') {
                    this.ctx.translate(this.canvas.width / 2, this.canvas.height / 2);
                    this.ctx.scale(0.8, 0.4);
                    this.ctx.translate(-this.canvas.width / 2, -this.canvas.height / 2);
                }
                
                // Draw tower
                this.tower.draw(this.ctx, this.physics.angle);
                
                // Draw characters
                this.ctx.save();
                this.ctx.translate(this.tower.baseX, this.tower.baseY);
                this.ctx.rotate(this.physics.angle);
                
                this.tower.getAllCharacters().forEach(char => {
                    char.draw(this.ctx, this.physics.angle);
                });
                
                this.ctx.restore();
                
                // Draw ghost preview
                if (this.ghostPreview) {
                    this.ctx.fillStyle = this.ghostPreview.valid ? 'rgba(0, 255, 163, 0.3)' : 'rgba(255, 51, 102, 0.3)';
                    this.ctx.beginPath();
                    this.ctx.arc(this.ghostPreview.x, this.ghostPreview.y, 25, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    if (!this.ghostPreview.valid) {
                        this.ctx.strokeStyle = '#ff3366';
                        this.ctx.lineWidth = 3;
                        this.ctx.beginPath();
                        this.ctx.moveTo(this.ghostPreview.x - 15, this.ghostPreview.y - 15);
                        this.ctx.lineTo(this.ghostPreview.x + 15, this.ghostPreview.y + 15);
                        this.ctx.moveTo(this.ghostPreview.x + 15, this.ghostPreview.y - 15);
                        this.ctx.lineTo(this.ghostPreview.x - 15, this.ghostPreview.y + 15);
                        this.ctx.stroke();
                    }
                }
                
                // Draw drag character
                if (this.dragCharacter) {
                    this.dragCharacter.draw(this.ctx, 0);
                }
                
                // Draw COM indicator (in top view)
                if (this.cameraMode === 'top') {
                    const com = this.physics.calculateCenterOfMass(this.tower.getAllCharacters());
                    this.ctx.fillStyle = '#00d9ff';
                    this.ctx.beginPath();
                    this.ctx.arc(this.tower.baseX + com.x, this.tower.baseY, 8, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                
                this.ctx.restore();
            }

            updateHUD() {
                document.getElementById('scoreDisplay').textContent = this.state.score;
                document.getElementById('turnDisplay').textContent = this.state.turn;
                document.getElementById('touristDisplay').textContent = this.state.tourists;
            }

            updateTimerDisplay() {
                const diffConfig = CONFIG.difficulty[this.state.difficulty];
                if (!diffConfig.timer) return;
                
                const percent = (this.timer / diffConfig.timerDuration) * 100;
                document.getElementById('timerBar').style.width = `${percent}%`;
            }

            updateStabilityDisplay() {
                const maxAngle = CONFIG.physics.maxAngle;
                const currentAngle = this.physics.getAngleDegrees();
                const percent = ((currentAngle / maxAngle) * 50) + 50;
                
                document.getElementById('stabilityBar').style.marginLeft = `${percent}%`;
            }

            gameOver() {
                this.state.gameOver = true;
                
                // Show game over screen
                document.getElementById('finalScore').textContent = this.state.score;
                document.getElementById('finalTourists').textContent = this.state.tourists;
                document.getElementById('finalAngle').textContent = `${this.state.maxAngle.toFixed(1)}Â°`;
                
                document.getElementById('gameOverScreen').style.display = 'flex';
                
                // Vibration
                if (navigator.vibrate) {
                    navigator.vibrate([200, 100, 200]);
                }
            }

            start() {
                this.state.reset();
                this.physics.reset();
                this.tower.reset();
                
                this.timer = 0;
                this.windTimer = 0;
                
                this.nextCharacterType = this.getRandomCharacterType();
                this.updateNextCharacterDisplay();
                this.updateHUD();
                
                // Show timer if needed
                const diffConfig = CONFIG.difficulty[this.state.difficulty];
                if (diffConfig.timer) {
                    document.getElementById('timerContainer').style.display = 'block';
                    this.maxTimer = diffConfig.timerDuration;
                } else {
                    document.getElementById('timerContainer').style.display = 'none';
                }
                
                if (diffConfig.wind) {
                    this.windInterval = diffConfig.windInterval;
                }
            }

            loop(timestamp) {
                if (!this.lastTimestamp) this.lastTimestamp = timestamp;
                const dt = Math.min((timestamp - this.lastTimestamp) / 1000, 0.033);
                this.lastTimestamp = timestamp;
                
                this.update(dt);
                this.draw();
                
                requestAnimationFrame((t) => this.loop(t));
            }
        }

        // ============================================
        // INITIALIZE GAME
        // ============================================
        let game;

        document.getElementById('startBtn').addEventListener('click', () => {
            const selectedDifficulty = document.querySelector('.difficulty-btn.selected').dataset.difficulty;
            
            if (!game) {
                game = new Game();
            }
            
            game.state.difficulty = selectedDifficulty;
            game.start();
            
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('gameOverScreen').style.display = 'none';
            
            requestAnimationFrame((t) => game.loop(t));
        });

        document.getElementById('restartBtn').addEventListener('click', () => {
            document.getElementById('gameOverScreen').style.display = 'none';
            game.start();
        });

        // Difficulty selector
        document.querySelectorAll('.difficulty-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.difficulty-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
            });
        });

        // Service Worker Registration
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js').then(registration => {
                console.log('Service Worker registered:', registration);
            }).catch(err => {
                console.log('Service Worker registration failed:', err);
            });
        }
    </script>
</body>
</html>
