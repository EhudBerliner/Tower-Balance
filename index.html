<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#ff6b35">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Tower Balance">
    <meta name="description" content="Physics-based tower balancing game â€“ manage center of mass and reach a new high score!">
    <title>Tower Balance</title>
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/png" href="icons/icon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="icons/icon-16x16.png" sizes="16x16">
    <link rel="apple-touch-icon" href="icons/icon-152x152.png">
    <link rel="apple-touch-icon" sizes="192x192" href="icons/icon-192x192.png">
    <script src="i18n.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@700;900&family=Rajdhani:wght@400;600;700&display=swap');

        * { margin:0; padding:0; box-sizing:border-box; -webkit-tap-highlight-color:transparent; }

        :root {
            --primary:#ff6b35; --secondary:#f7931e; --accent:#00d9ff;
            --bg-dark:#0a0e27; --bg-mid:#1a1f3a;
            --text:#ffffff; --text-dim:#8892b0;
            --success:#00ffa3; --danger:#ff3366; --shadow:rgba(0,0,0,0.4);
            --safe-top:env(safe-area-inset-top,0px);
            --safe-bottom:env(safe-area-inset-bottom,0px);
        }

        /* Light mode (default) */
        body {
            font-family:'Rajdhani',sans-serif;
            background:linear-gradient(160deg,#e8f0ff 0%,#f5f0ff 50%,#fff4ee 100%);
            color:#1a1f3a; overflow:hidden; touch-action:manipulation;
            height:100dvh; position:relative;
        }
        body::before {
            content:''; position:absolute; inset:0; z-index:0; pointer-events:none;
            background:radial-gradient(ellipse at 20% 60%,rgba(255,107,53,.07),transparent 60%),
                       radial-gradient(ellipse at 80% 20%,rgba(0,217,255,.07),transparent 60%);
        }

        /* Dark mode */
        body.dark-mode {
            background:linear-gradient(135deg,#0a0e27 0%,#0f1333 50%,#1a1f3a 100%);
            color:#fff;
        }
        body.dark-mode::before {
            background:radial-gradient(ellipse at 20% 50%,rgba(255,107,53,.1),transparent 50%),
                       radial-gradient(ellipse at 80% 80%,rgba(0,217,255,.1),transparent 50%);
        }

        /* â”€â”€ Canvas â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        #gameCanvas { position:absolute; inset:0; width:100%; height:100%; z-index:1; cursor:grab; touch-action:none; }
        #gameCanvas:active { cursor:grabbing; }

        /* â”€â”€ HUD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        #hud {
            position:absolute; top:0; left:0; width:100%;
            padding:calc(8px + var(--safe-top)) 10px 0;
            z-index:10; pointer-events:none; box-sizing:border-box;
        }
        /* Row 1: [54px gap for â˜°] score | info | [68px gap for version] */
        .hud-top {
            display:flex; align-items:flex-start; gap:6px;
            padding-left:54px; padding-right:74px;
        }
        .hud-panel {
            background:rgba(255,255,255,0.88); backdrop-filter:blur(12px);
            border:1.5px solid rgba(255,107,53,0.25); border-radius:14px;
            padding:8px 12px; box-shadow:0 4px 18px rgba(0,0,0,.1);
            pointer-events:auto; flex-shrink:0;
        }
        body.dark-mode .hud-panel { background:rgba(26,31,58,0.85); box-shadow:0 4px 18px rgba(0,0,0,.4); }
        .score-label { font-size:10px; color:#8892b0; text-transform:uppercase; letter-spacing:2px; margin-bottom:2px; }
        .score-value { font-family:'Orbitron',monospace; font-size:22px; font-weight:900; color:var(--accent); line-height:1; }
        .info-panel { display:flex; flex-direction:column; gap:5px; flex:1; min-width:0; }
        .info-row { display:flex; justify-content:space-between; align-items:center; gap:8px; }
        .info-label { font-size:10px; color:#8892b0; text-transform:uppercase; white-space:nowrap; }
        .info-value { font-family:'Orbitron',monospace; font-size:13px; font-weight:700; color:var(--primary); }
        .timer-container { height:6px; background:rgba(0,0,0,.12); border-radius:6px; overflow:hidden; margin-top:4px; }
        .timer-bar { height:100%; background:linear-gradient(90deg,var(--success),var(--secondary),var(--danger)); border-radius:6px; transition:width .1s linear; }

        /* Row 2: Next character â€” in-flow, centered, with side margins to avoid buttons */
        .next-character {
            display:flex; align-items:center; gap:8px;
            width:fit-content; max-width:calc(100% - 130px);
            margin:6px auto 0 auto;
            background:rgba(255,255,255,0.88); backdrop-filter:blur(12px);
            border:1.5px solid rgba(255,107,53,0.3); border-radius:40px;
            padding:6px 16px; box-shadow:0 4px 18px rgba(0,0,0,.1); white-space:nowrap;
            pointer-events:none;
        }
        body.dark-mode .next-character { background:rgba(26,31,58,0.88); }
        .next-label { font-size:10px; color:#8892b0; text-transform:uppercase; }
        .next-icon { font-size:22px; line-height:1; }
        .next-type { font-family:'Orbitron',monospace; font-size:12px; font-weight:700; color:var(--accent); }

        /* â”€â”€ Version Badge â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        #versionBadge {
            position:absolute; top:calc(8px + var(--safe-top)); right:10px;
            font-size:10px; color:#8892b0; cursor:pointer;
            background:rgba(255,255,255,0.7); border-radius:6px; padding:2px 7px;
            z-index:20; user-select:none; border:1px solid rgba(255,107,53,.15);
            pointer-events:auto;
        }
        body.dark-mode #versionBadge { background:rgba(26,31,58,0.7); }
        #versionBadge:hover { color:var(--primary); }

        /* â”€â”€ Hamburger â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        #menuBtn {
            position:absolute; top:calc(12px + var(--safe-top)); left:10px;
            width:44px; height:44px; border-radius:12px;
            border:1.5px solid rgba(255,107,53,.3);
            background:rgba(255,255,255,0.82); backdrop-filter:blur(12px);
            color:#1a1f3a; font-size:20px; cursor:pointer; z-index:20;
            display:flex; align-items:center; justify-content:center;
            box-shadow:0 3px 12px rgba(0,0,0,.1); pointer-events:auto;
        }
        body.dark-mode #menuBtn { background:rgba(26,31,58,0.88); color:#fff; }

        /* â”€â”€ Side Menu â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        #menuOverlay { position:fixed; inset:0; background:rgba(0,0,0,.45); z-index:200; opacity:0; pointer-events:none; transition:opacity .3s; }
        #menuOverlay.open { opacity:1; pointer-events:auto; }
        #sideMenu {
            position:fixed; top:0; left:-290px; width:290px; height:100%;
            background:#fff; border-right:1.5px solid rgba(255,107,53,.2);
            z-index:201; padding:calc(24px + var(--safe-top)) 20px 24px;
            transition:left .3s cubic-bezier(.4,0,.2,1);
            display:flex; flex-direction:column; gap:8px; overflow-y:auto;
        }
        body.dark-mode #sideMenu { background:#0f1333; }
        #sideMenu.open { left:0; }
        .menu-title { font-family:'Orbitron',monospace; font-size:18px; font-weight:900; color:var(--primary); margin-bottom:16px; }
        .menu-item {
            padding:13px 16px; border-radius:12px; border:1px solid rgba(255,107,53,.15);
            background:rgba(255,107,53,.05); color:#1a1f3a; font-size:16px;
            font-weight:600; cursor:pointer; display:flex; align-items:center; gap:12px; transition:all .2s;
        }
        body.dark-mode .menu-item { background:rgba(26,31,58,.6); color:#fff; }
        .menu-item:hover { background:rgba(255,107,53,.12); border-color:var(--primary); }
        .menu-item .mi-icon { font-size:20px; }

        /* â”€â”€ Stability Meter â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .stability-container {
            position:absolute; bottom:calc(28px + var(--safe-bottom)); left:50%; transform:translateX(-50%);
            width:280px; max-width:88vw; z-index:10; pointer-events:none;
        }
        .stability-label { text-align:center; font-size:10px; color:#8892b0; margin-bottom:6px; text-transform:uppercase; letter-spacing:2px; }
        .stability-track {
            position:relative; height:18px;
            background:rgba(0,0,0,.08); border-radius:10px;
            border:1.5px solid rgba(255,107,53,.3); overflow:visible;
        }
        body.dark-mode .stability-track { background:rgba(0,0,0,.4); }
        /* Gradient fill showing danger zones */
        .stability-track::before {
            content:''; position:absolute; inset:0; border-radius:8px;
            background:linear-gradient(90deg,
                rgba(255,51,102,.5) 0%, rgba(255,107,53,.3) 25%,
                rgba(0,255,163,.2) 40%, rgba(0,255,163,.2) 60%,
                rgba(255,107,53,.3) 75%, rgba(255,51,102,.5) 100%);
        }
        /* Center safe-zone marker */
        .stability-track::after {
            content:''; position:absolute; top:0; bottom:0; left:50%;
            width:2px; background:rgba(0,0,0,.2); transform:translateX(-50%);
        }
        /* Needle */
        #stabilityNeedle {
            position:absolute; top:-4px; bottom:-4px; width:6px; border-radius:3px;
            background:#ff6b35; box-shadow:0 0 10px rgba(255,107,53,.7);
            transform:translateX(-50%); left:50%;
            transition:left .08s linear, background .3s;
        }

        /* â”€â”€ Camera Controls â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .controls {
            position:absolute; bottom:calc(76px + var(--safe-bottom)); right:14px;
            display:flex; flex-direction:column; gap:10px; z-index:10;
        }
        .control-btn {
            width:52px; height:52px; border-radius:50%;
            border:1.5px solid rgba(0,217,255,.5);
            background:rgba(255,255,255,0.82); backdrop-filter:blur(10px);
            color:#1a1f3a; font-size:20px; cursor:pointer; transition:all .25s;
            box-shadow:0 3px 14px rgba(0,0,0,.1);
            display:flex; align-items:center; justify-content:center; pointer-events:auto;
        }
        body.dark-mode .control-btn { background:rgba(26,31,58,0.88); color:var(--accent); }
        .control-btn:hover { transform:scale(1.1); box-shadow:0 0 22px rgba(0,217,255,.4); }
        .control-btn:active { transform:scale(.94); }
        .control-btn.active { background:var(--accent); color:#0a0e27; border-color:var(--accent); }

        /* â”€â”€ Start Screen â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        #startScreen {
            position:absolute; inset:0; z-index:100;
            background:linear-gradient(160deg,rgba(232,240,255,.97),rgba(255,244,238,.97));
            backdrop-filter:blur(20px);
            display:flex; flex-direction:column; justify-content:center; align-items:center;
            padding:24px; gap:0;
        }
        body.dark-mode #startScreen { background:linear-gradient(135deg,rgba(10,14,39,.97),rgba(15,19,51,.97)); }
        .game-logo { width:100px; height:100px; border-radius:22px; object-fit:cover; margin-bottom:16px; box-shadow:0 8px 28px rgba(255,107,53,.35); }
        .game-title {
            font-family:'Orbitron',monospace; font-size:38px; font-weight:900;
            text-align:center; margin-bottom:10px;
            background:linear-gradient(135deg,var(--primary),var(--secondary),var(--accent));
            -webkit-background-clip:text; -webkit-text-fill-color:transparent; background-clip:text;
        }
        .game-subtitle { font-size:15px; color:#8892b0; text-align:center; margin-bottom:10px; max-width:340px; }
        .best-score-row { font-size:13px; color:#8892b0; margin-bottom:24px; }
        .best-score-row span { color:var(--accent); font-family:'Orbitron',monospace; font-weight:700; }
        .difficulty-selector { display:flex; gap:10px; margin-bottom:24px; flex-wrap:wrap; justify-content:center; }
        .difficulty-btn {
            padding:11px 22px; border-radius:10px; border:1.5px solid var(--accent);
            background:transparent; color:#1a1f3a;
            font-family:'Rajdhani',sans-serif; font-size:16px; font-weight:700;
            cursor:pointer; transition:all .25s; text-transform:uppercase;
        }
        body.dark-mode .difficulty-btn { color:#fff; }
        .difficulty-btn:hover { background:rgba(0,217,255,.1); transform:translateY(-2px); }
        .difficulty-btn.selected { background:var(--accent); color:#0a0e27; }
        .start-btn {
            padding:16px 52px; border-radius:50px; border:none;
            background:linear-gradient(135deg,var(--primary),var(--secondary));
            color:#fff; font-family:'Orbitron',monospace; font-size:20px; font-weight:900;
            cursor:pointer; transition:all .25s; text-transform:uppercase;
            box-shadow:0 8px 28px rgba(255,107,53,.4); letter-spacing:1px;
        }
        .start-btn:hover { transform:translateY(-3px) scale(1.04); box-shadow:0 12px 36px rgba(255,107,53,.55); }

        /* â”€â”€ Game Over Screen â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        #gameOverScreen {
            position:absolute; inset:0; z-index:100;
            background:linear-gradient(160deg,rgba(232,240,255,.97),rgba(255,244,238,.97));
            backdrop-filter:blur(20px);
            display:none; flex-direction:column; justify-content:center; align-items:center;
            padding:24px;
        }
        body.dark-mode #gameOverScreen { background:linear-gradient(135deg,rgba(10,14,39,.97),rgba(15,19,51,.97)); }
        .game-over-title { font-family:'Orbitron',monospace; font-size:40px; font-weight:900; color:var(--danger); margin-bottom:8px; animation:shake .5s ease-out; }
        @keyframes shake { 0%,100%{transform:translateX(0)} 25%{transform:translateX(-10px) rotate(-2deg)} 75%{transform:translateX(10px) rotate(2deg)} }
        #newHighScoreMsg { font-size:18px; color:var(--secondary); margin-bottom:18px; min-height:26px; }
        .final-stats { background:rgba(255,255,255,.7); border:1.5px solid rgba(255,107,53,.25); border-radius:18px; padding:22px 32px; margin-bottom:26px; min-width:260px; }
        body.dark-mode .final-stats { background:rgba(26,31,58,.8); }
        .stat-row { display:flex; justify-content:space-between; padding:10px 0; border-bottom:1px solid rgba(0,0,0,.07); }
        .stat-row:last-child { border-bottom:none; }
        .stat-label { font-size:15px; color:#8892b0; }
        .stat-value { font-family:'Orbitron',monospace; font-size:20px; font-weight:700; color:var(--accent); }
        .restart-btn {
            padding:14px 44px; border-radius:50px; border:none;
            background:linear-gradient(135deg,var(--primary),var(--secondary));
            color:#fff; font-family:'Orbitron',monospace; font-size:17px; font-weight:900;
            cursor:pointer; transition:all .25s; text-transform:uppercase; box-shadow:0 8px 28px rgba(255,107,53,.4);
        }
        .restart-btn:hover { transform:translateY(-3px) scale(1.04); }

        /* â”€â”€ Modals â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .modal-backdrop {
            position:fixed; inset:0; background:rgba(0,0,0,.55);
            backdrop-filter:blur(6px); z-index:300; display:none;
            align-items:center; justify-content:center;
        }
        .modal-backdrop.open { display:flex; }
        .modal-box {
            background:#fff; border:1.5px solid rgba(255,107,53,.25);
            border-radius:20px; padding:28px; width:340px; max-width:94vw;
            max-height:92vh; overflow-y:auto; animation:modalIn .22s ease-out;
        }
        body.dark-mode .modal-box { background:#0f1333; }
        @keyframes modalIn { from{transform:scale(.88);opacity:0} to{transform:scale(1);opacity:1} }
        .modal-title { font-family:'Orbitron',monospace; font-size:18px; font-weight:900; color:var(--primary); margin-bottom:20px; }
        .setting-row { display:flex; align-items:center; justify-content:space-between; margin-bottom:14px; }
        .setting-label { font-size:15px; color:#1a1f3a; }
        body.dark-mode .setting-label { color:#fff; }
        .toggle { position:relative; width:46px; height:25px; }
        .toggle input { opacity:0; width:0; height:0; }
        .toggle-slider { position:absolute; inset:0; background:#ccc; border-radius:25px; cursor:pointer; transition:.3s; }
        .toggle-slider:before { content:''; position:absolute; height:19px; width:19px; left:3px; bottom:3px; background:#fff; border-radius:50%; transition:.3s; }
        input:checked + .toggle-slider { background:var(--primary); }
        input:checked + .toggle-slider:before { transform:translateX(21px); }
        .modal-select { background:#f0f4ff; border:1px solid rgba(255,107,53,.25); color:#1a1f3a; border-radius:9px; padding:7px 12px; font-size:14px; cursor:pointer; }
        body.dark-mode .modal-select { background:#1a1f3a; color:#fff; }
        .modal-btn { width:100%; padding:12px; border-radius:11px; border:none; cursor:pointer; font-size:15px; font-weight:700; margin-top:9px; transition:all .2s; }
        .modal-btn-primary { background:linear-gradient(135deg,var(--primary),var(--secondary)); color:#fff; }
        .modal-btn-secondary { background:rgba(136,146,176,.15); color:#8892b0; border:1px solid rgba(136,146,176,.25); }
        .modal-btn-danger { background:rgba(255,51,102,.1); color:var(--danger); border:1px solid rgba(255,51,102,.25); }
        .modal-divider { height:1px; background:rgba(255,107,53,.12); margin:14px 0; }
        .check-row { display:flex; align-items:center; gap:10px; margin-bottom:10px; cursor:pointer; }
        .check-row input[type=checkbox] { width:17px; height:17px; accent-color:var(--primary); cursor:pointer; }
        .check-row label { font-size:14px; color:#1a1f3a; cursor:pointer; }
        body.dark-mode .check-row label { color:#fff; }
        .stats-row { display:flex; justify-content:space-between; padding:9px 0; border-bottom:1px solid rgba(0,0,0,.06); }
        .stats-key { color:#8892b0; font-size:14px; }
        .stats-val { color:var(--accent); font-family:'Orbitron',monospace; font-size:15px; font-weight:700; }

        /* â”€â”€ Toasts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        #toastContainer {
            position:fixed; top:calc(64px + var(--safe-top)); left:50%; transform:translateX(-50%);
            z-index:500; display:flex; flex-direction:column; align-items:center; gap:7px; pointer-events:none;
        }
        .toast {
            padding:10px 22px; border-radius:50px; font-size:14px; font-weight:700;
            backdrop-filter:blur(12px); box-shadow:0 4px 18px rgba(0,0,0,.2);
            animation:toastIn .25s ease-out; white-space:nowrap;
        }
        .toast.info    { background:rgba(0,217,255,.15); border:1px solid var(--accent); color:var(--accent); }
        .toast.success { background:rgba(0,255,163,.15); border:1px solid var(--success); color:var(--success); }
        .toast.error   { background:rgba(255,51,102,.15); border:1px solid var(--danger);  color:var(--danger);  }
        @keyframes toastIn { from{transform:translateY(-14px);opacity:0} to{transform:translateY(0);opacity:1} }

        /* â”€â”€ Offline Banner â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        #offlineBanner {
            position:fixed; top:0; left:0; right:0;
            background:var(--danger); color:#fff; text-align:center;
            padding:calc(9px + var(--safe-top)) 14px 9px;
            font-size:13px; font-weight:700; z-index:400;
            transform:translateY(-110%); transition:transform .3s;
        }
        #offlineBanner.show { transform:translateY(0); }

        /* â”€â”€ PWA Install Banner â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        #installBanner {
            position:fixed; bottom:-180px; left:0; right:0;
            background:#fff; border-top:1.5px solid rgba(255,107,53,.25);
            padding:16px 18px calc(16px + var(--safe-bottom));
            z-index:250; transition:bottom .4s cubic-bezier(.4,0,.2,1);
            display:flex; align-items:center; gap:12px;
        }
        body.dark-mode #installBanner { background:#0f1333; }
        #installBanner.show { bottom:0; }
        #installBanner img { width:48px; height:48px; border-radius:11px; }
        .install-text { flex:1; }
        .install-title { font-size:15px; font-weight:700; color:#1a1f3a; margin-bottom:2px; }
        body.dark-mode .install-title { color:#fff; }
        .install-desc  { font-size:12px; color:#8892b0; }
        #installBtn { padding:9px 18px; border-radius:11px; border:none; background:linear-gradient(135deg,var(--primary),var(--secondary)); color:#fff; font-weight:700; font-size:13px; cursor:pointer; }
        #installDismissBtn { background:none; border:none; color:#8892b0; font-size:20px; cursor:pointer; padding:3px; }

        /* â”€â”€ PTR â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        #ptr-indicator {
            position:fixed; top:var(--safe-top); left:50%; transform:translateX(-50%);
            background:rgba(255,255,255,.9); border-radius:50px; padding:7px 18px;
            font-size:12px; color:#8892b0; z-index:50; opacity:0; pointer-events:none; transition:opacity .2s;
        }

        /* â”€â”€ Tilt warning flash â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        @keyframes dangerPulse {
            0%,100% { box-shadow: inset 0 0 0px rgba(255,51,102,0); }
            50%      { box-shadow: inset 0 0 60px rgba(255,51,102,0.18); }
        }
        body.danger-tilt { animation: dangerPulse .6s ease-in-out infinite; }

        /* â”€â”€ Responsive â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        @media(max-width:480px) {
            .game-title { font-size:28px; }
            .score-value { font-size:22px; }
            .controls { bottom:calc(56px + var(--safe-bottom)); right:8px; }
            .control-btn { width:46px; height:46px; font-size:18px; }
        }
    </style>
</head>
<body>

<!-- â•â•â• Offline Banner â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div id="offlineBanner" data-i18n="offlineBanner">No internet connection</div>

<!-- â•â•â• Toasts â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div id="toastContainer"></div>

<!-- â•â•â• PTR â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div id="ptr-indicator">â†“ Pull to refresh</div>

<!-- â•â•â• Version Badge â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div id="versionBadge" title="Click 5Ã— to hard-reset">v1.0.0</div>

<!-- â•â•â• Hamburger â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<button id="menuBtn" aria-label="Menu">â˜°</button>

<!-- â•â•â• Side Menu â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div id="menuOverlay"></div>
<nav id="sideMenu">
    <div class="menu-title" data-i18n="menuTitle">Menu</div>
    <div class="menu-item" id="menuNewGame"><span class="mi-icon">ğŸ®</span><span data-i18n="menuNewGame">New Game</span></div>
    <div class="menu-item" id="menuSettingsBtn"><span class="mi-icon">âš™ï¸</span><span data-i18n="menuSettings">Settings</span></div>
    <div class="menu-item" id="menuStatsBtn"><span class="mi-icon">ğŸ“Š</span><span data-i18n="menuStats">Statistics</span></div>
</nav>

<!-- â•â•â• Start Screen â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div id="startScreen">
    <img src="icons/icon-192x192.png" alt="Tower Balance Logo" class="game-logo">
    <h1 class="game-title">ğŸ—ï¸ Tower Balance</h1>
    <p class="game-subtitle" data-i18n="appSubtitle">Manage center of mass, keep balance and reach a new high score!</p>
    <p class="best-score-row"><span data-i18n="bestScore">Best Score</span>: <span id="bestScoreDisplay">0</span></p>
    <div class="difficulty-selector">
        <button class="difficulty-btn"          data-difficulty="easy"   data-i18n="diffEasy">Easy</button>
        <button class="difficulty-btn selected" data-difficulty="medium" data-i18n="diffMedium">Medium</button>
        <button class="difficulty-btn"          data-difficulty="hard"   data-i18n="diffHard">Hard</button>
        <button class="difficulty-btn"          data-difficulty="expert" data-i18n="diffExpert">Expert</button>
    </div>
    <button class="start-btn" id="startBtn" data-i18n="startBtn">Start Game</button>
</div>

<!-- â•â•â• Game Over â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div id="gameOverScreen">
    <h1 class="game-over-title" data-i18n="gameOverTitle">Tower Collapsed!</h1>
    <p id="newHighScoreMsg"></p>
    <div class="final-stats">
        <div class="stat-row"><span class="stat-label" data-i18n="gameOverScore">Score</span><span class="stat-value" id="finalScore">0</span></div>
        <div class="stat-row"><span class="stat-label" data-i18n="gameOverTourists">Tourists</span><span class="stat-value" id="finalTourists">0</span></div>
        <div class="stat-row"><span class="stat-label" data-i18n="gameOverMaxAngle">Max Angle</span><span class="stat-value" id="finalAngle">0Â°</span></div>
    </div>
    <button class="restart-btn" id="restartBtn" data-i18n="restartBtn">Play Again</button>
</div>

<!-- â•â•â• Canvas â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<canvas id="gameCanvas"></canvas>

<!-- â•â•â• HUD â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div id="hud">
    <div class="hud-top">
        <div class="hud-panel">
            <div class="score-label" data-i18n="hudScore">Score</div>
            <div class="score-value" id="scoreDisplay">0</div>
        </div>
        <div class="hud-panel info-panel">
            <div class="info-row">
                <span class="info-label" data-i18n="hudTurn">Turn</span>
                <span class="info-value" id="turnDisplay">1</span>
            </div>
            <div class="info-row">
                <span class="info-label" data-i18n="hudTourists">Tourists</span>
                <span class="info-value" id="touristDisplay">0</span>
            </div>
            <div class="timer-container" id="timerContainer" style="display:none">
                <div class="timer-bar" id="timerBar" style="width:100%"></div>
            </div>
        </div>
    </div>
    <div class="next-character">
        <span class="next-label" data-i18n="hudNext">Next:</span>
        <span class="next-icon" id="nextIcon">ğŸ‘¤</span>
        <span class="next-type" id="nextType">Regular</span>
    </div>
</div>

<!-- â•â•â• Stability Meter â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div class="stability-container">
    <div class="stability-label" data-i18n="hudStability">Stability</div>
    <div class="stability-track">
        <div id="stabilityNeedle"></div>
    </div>
</div>

<!-- â•â•â• Camera Controls â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div class="controls">
    <button class="control-btn" id="topViewBtn"   title="Top View">â¬‡ï¸</button>
    <button class="control-btn active" id="defaultViewBtn" title="Default View">ğŸ¯</button>
    <button class="control-btn" id="horizonBtn"   title="Horizon View">â†”ï¸</button>
</div>

<!-- â•â•â• PWA Install Banner â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div id="installBanner">
    <img src="icons/icon-192x192.png" alt="Icon">
    <div class="install-text">
        <div class="install-title" data-i18n="installTitle">Install App</div>
        <div class="install-desc"  data-i18n="installDesc">Install for quick access and offline play!</div>
    </div>
    <button id="installBtn" data-i18n="installBtn">Install</button>
    <button id="installDismissBtn" aria-label="Dismiss">âœ•</button>
</div>

<!-- â•â•â• Settings Modal â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div class="modal-backdrop" id="settingsModal">
    <div class="modal-box">
        <div class="modal-title" data-i18n="settingsTitle">Settings</div>
        <div class="setting-row">
            <span class="setting-label" data-i18n="settingsLanguage">Language</span>
            <select class="modal-select" id="langSelect">
                <option value="en">English</option>
                <option value="he">×¢×‘×¨×™×ª</option>
            </select>
        </div>
        <div class="setting-row">
            <span class="setting-label" data-i18n="settingsDarkMode">Dark Mode</span>
            <label class="toggle"><input type="checkbox" id="darkModeToggle"><span class="toggle-slider"></span></label>
        </div>
        <div class="setting-row">
            <span class="setting-label" data-i18n="settingsVibration">Vibration</span>
            <label class="toggle"><input type="checkbox" id="vibrationToggle" checked><span class="toggle-slider"></span></label>
        </div>
        <div class="setting-row">
            <span class="setting-label" data-i18n="settingsSounds">Sound Effects</span>
            <label class="toggle"><input type="checkbox" id="soundToggle" checked><span class="toggle-slider"></span></label>
        </div>
        <div class="setting-row">
            <span class="setting-label" data-i18n="settingsAnimations">Animations</span>
            <label class="toggle"><input type="checkbox" id="animToggle" checked><span class="toggle-slider"></span></label>
        </div>
        <div class="setting-row">
            <span class="setting-label" data-i18n="settingsPullRefresh">Pull to Refresh</span>
            <label class="toggle"><input type="checkbox" id="ptrToggle"><span class="toggle-slider"></span></label>
        </div>
        <div class="modal-divider"></div>
        <button class="modal-btn modal-btn-danger" id="openResetModalBtn" data-i18n="settingsReset">Reset Data</button>
        <button class="modal-btn modal-btn-secondary" id="closeSettingsBtn" data-i18n="settingsClose">Close</button>
    </div>
</div>

<!-- â•â•â• Stats Modal â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div class="modal-backdrop" id="statsModal">
    <div class="modal-box">
        <div class="modal-title" data-i18n="statsTitle">Statistics</div>
        <div class="stats-row"><span class="stats-key" data-i18n="statsGamesPlayed">Games Played</span><span class="stats-val" id="statGames">0</span></div>
        <div class="stats-row"><span class="stats-key" data-i18n="statsBestScore">Best Score</span><span class="stats-val" id="statBest">0</span></div>
        <div class="stats-row"><span class="stats-key" data-i18n="statsBestTourists">Most Tourists</span><span class="stats-val" id="statBestTourists">0</span></div>
        <div class="stats-row"><span class="stats-key" data-i18n="statsTotalTourists">Total Tourists</span><span class="stats-val" id="statTotal">0</span></div>
        <button class="modal-btn modal-btn-secondary" id="closeStatsBtn" style="margin-top:18px" data-i18n="statsClose">Close</button>
    </div>
</div>

<!-- â•â•â• Reset Modal â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div class="modal-backdrop" id="resetModal">
    <div class="modal-box">
        <div class="modal-title" data-i18n="resetTitle">Reset Data</div>
        <p style="color:#8892b0;font-size:13px;margin-bottom:14px" data-i18n="resetDesc">Select what to keep before resetting:</p>
        <label class="check-row"><input type="checkbox" id="keepProgress"><label for="keepProgress" data-i18n="resetKeepProgress">Keep game progress</label></label>
        <label class="check-row"><input type="checkbox" id="keepHighScore" checked><label for="keepHighScore" data-i18n="resetKeepHighScore">Keep high scores</label></label>
        <label class="check-row"><input type="checkbox" id="keepSettings" checked><label for="keepSettings" data-i18n="resetKeepSettings">Keep settings</label></label>
        <button class="modal-btn modal-btn-danger"     id="confirmResetBtn" data-i18n="resetConfirm">Reset Now</button>
        <button class="modal-btn modal-btn-secondary"  id="cancelResetBtn"  data-i18n="resetCancel">Cancel</button>
    </div>
</div>

<script>
'use strict';
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// VERSION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const APP_VERSION = '1.1.0';
document.getElementById('versionBadge').textContent = 'v' + APP_VERSION;

const storedVer = localStorage.getItem('tb_version');
if (storedVer && storedVer !== APP_VERSION) {
    (async () => {
        if ('caches' in window) { const k = await caches.keys(); await Promise.all(k.map(c => caches.delete(c))); }
        localStorage.setItem('tb_version', APP_VERSION);
        location.reload(true);
    })();
} else { localStorage.setItem('tb_version', APP_VERSION); }

let vClicks = 0, vTimer;
document.getElementById('versionBadge').addEventListener('click', () => {
    if (++vClicks >= 5) { vClicks = 0; hardReset(); }
    clearTimeout(vTimer); vTimer = setTimeout(() => vClicks = 0, 2000);
});
async function hardReset() {
    if (!confirm('Hard reset? ALL data will be erased.')) return;
    localStorage.clear(); sessionStorage.clear();
    document.cookie.split(';').forEach(c => document.cookie = c.replace(/^ +/,'').replace(/=.*/,'=;expires='+new Date().toUTCString()+';path=/'));
    if ('serviceWorker' in navigator) { const r = await navigator.serviceWorker.getRegistrations(); await Promise.all(r.map(x => x.unregister())); }
    if ('caches' in window) { const k = await caches.keys(); await Promise.all(k.map(c => caches.delete(c))); }
    location.reload(true);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SETTINGS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const DEFAULT_SETTINGS = { lang:'en', darkMode:false, vibration:true, sounds:true, animations:true, pullToRefresh:false };
function loadSettings() { try { return Object.assign({},DEFAULT_SETTINGS,JSON.parse(localStorage.getItem('tb_settings')||'{}')); } catch { return {...DEFAULT_SETTINGS}; } }
function saveSettings(s) { localStorage.setItem('tb_settings', JSON.stringify(s)); }
let settings = loadSettings();

function applyTheme() { document.body.classList.toggle('dark-mode', !!settings.darkMode); }
function initSettings() {
    applyTranslations(settings.lang);
    applyTheme();
    document.getElementById('langSelect').value        = settings.lang;
    document.getElementById('darkModeToggle').checked  = settings.darkMode;
    document.getElementById('vibrationToggle').checked = settings.vibration;
    document.getElementById('soundToggle').checked     = settings.sounds;
    document.getElementById('animToggle').checked      = settings.animations;
    document.getElementById('ptrToggle').checked       = settings.pullToRefresh;
}
document.getElementById('langSelect').addEventListener('change', e => {
    settings.lang = e.target.value; saveSettings(settings);
    applyTranslations(settings.lang);
    document.documentElement.dir = settings.lang === 'he' ? 'rtl' : 'ltr';
    if (game) game.updateNextCharDisplay();
});
document.getElementById('darkModeToggle').addEventListener('change', e => { settings.darkMode = e.target.checked; saveSettings(settings); applyTheme(); });
document.getElementById('vibrationToggle').addEventListener('change', e => { settings.vibration = e.target.checked; saveSettings(settings); });
document.getElementById('soundToggle').addEventListener('change', e => { settings.sounds = e.target.checked; saveSettings(settings); });
document.getElementById('animToggle').addEventListener('change', e => { settings.animations = e.target.checked; saveSettings(settings); });
document.getElementById('ptrToggle').addEventListener('change', e => { settings.pullToRefresh = e.target.checked; saveSettings(settings); });

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TOAST
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function showToast(msg, type='info', dur=2500) {
    const c = document.getElementById('toastContainer');
    const el = document.createElement('div');
    el.className = `toast ${type}`; el.textContent = msg; c.appendChild(el);
    setTimeout(() => { el.style.opacity='0'; el.style.transition='opacity .3s'; setTimeout(() => el.remove(), 350); }, dur);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// OFFLINE / NETWORK
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const offBanner = document.getElementById('offlineBanner');
window.addEventListener('offline', () => offBanner.classList.add('show'));
window.addEventListener('online',  () => { offBanner.classList.remove('show'); showToast(t('onlineToast'),'success'); });
if (!navigator.onLine) offBanner.classList.add('show');
if ('connection' in navigator) {
    const ch = () => { if (navigator.connection.saveData || ['2g','slow-2g'].includes(navigator.connection.effectiveType)) showToast(t('slowConnectionToast'),'info',5000); };
    navigator.connection.addEventListener('change', ch); ch();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PWA INSTALL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let deferredPrompt = null;
const installBanner = document.getElementById('installBanner');
window.addEventListener('beforeinstallprompt', e => {
    e.preventDefault();
    if (localStorage.getItem('tb_install_dismissed')) return;
    deferredPrompt = e; setTimeout(() => installBanner.classList.add('show'), 3000);
});
document.getElementById('installBtn').addEventListener('click', async () => {
    if (!deferredPrompt) return;
    deferredPrompt.prompt();
    const { outcome } = await deferredPrompt.userChoice;
    deferredPrompt = null; installBanner.classList.remove('show');
    if (outcome === 'accepted') showToast(t('toastInstalled'),'success',3000);
});
document.getElementById('installDismissBtn').addEventListener('click', () => {
    installBanner.classList.remove('show'); localStorage.setItem('tb_install_dismissed','1');
});
window.addEventListener('appinstalled', () => { installBanner.classList.remove('show'); showToast(t('toastInstalled'),'success',3000); });

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MENU
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const menuOverlay = document.getElementById('menuOverlay');
const sideMenu    = document.getElementById('sideMenu');
function openMenu()  { sideMenu.classList.add('open'); menuOverlay.classList.add('open'); }
function closeMenu() { sideMenu.classList.remove('open'); menuOverlay.classList.remove('open'); }
document.getElementById('menuBtn').addEventListener('click', openMenu);
menuOverlay.addEventListener('click', closeMenu);
document.getElementById('menuNewGame').addEventListener('click',    () => { closeMenu(); document.getElementById('startScreen').style.display='flex'; });
document.getElementById('menuSettingsBtn').addEventListener('click',() => { closeMenu(); openModal('settingsModal'); });
document.getElementById('menuStatsBtn').addEventListener('click',   () => { closeMenu(); openStatsModal(); });

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MODALS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function openModal(id)  { document.getElementById(id).classList.add('open');    document.body.style.overflow='hidden'; }
function closeModal(id) { document.getElementById(id).classList.remove('open'); document.body.style.overflow=''; }
document.getElementById('closeSettingsBtn').addEventListener('click', () => closeModal('settingsModal'));
document.getElementById('closeStatsBtn').addEventListener('click',    () => closeModal('statsModal'));
document.getElementById('cancelResetBtn').addEventListener('click',   () => closeModal('resetModal'));
document.getElementById('openResetModalBtn').addEventListener('click',() => { closeModal('settingsModal'); openModal('resetModal'); });
['settingsModal','statsModal','resetModal'].forEach(id => document.getElementById(id).addEventListener('click', e => { if (e.target===e.currentTarget) closeModal(id); }));

document.getElementById('confirmResetBtn').addEventListener('click', async () => {
    const kp = document.getElementById('keepProgress').checked;
    const kh = document.getElementById('keepHighScore').checked;
    const ks = document.getElementById('keepSettings').checked;
    const prog = kp ? localStorage.getItem('tb_gamestate') : null;
    const stat = kh ? localStorage.getItem('tb_stats')     : null;
    const sett = ks ? localStorage.getItem('tb_settings')  : null;
    localStorage.clear();
    if (prog) localStorage.setItem('tb_gamestate', prog);
    if (stat) localStorage.setItem('tb_stats',     stat);
    if (sett) localStorage.setItem('tb_settings',  sett);
    localStorage.setItem('tb_version', APP_VERSION);
    if ('serviceWorker' in navigator) { const r = await navigator.serviceWorker.getRegistrations(); await Promise.all(r.map(x=>x.unregister())); }
    if ('caches' in window) { const k = await caches.keys(); await Promise.all(k.map(c=>caches.delete(c))); }
    closeModal('resetModal'); showToast(t('toastResetDone'),'success');
    setTimeout(() => location.reload(true), 800);
});

function openStatsModal() {
    const s = loadStats();
    document.getElementById('statGames').textContent        = s.gamesPlayed   || 0;
    document.getElementById('statBest').textContent         = s.bestScore     || 0;
    document.getElementById('statBestTourists').textContent = s.bestTourists  || 0;
    document.getElementById('statTotal').textContent        = s.totalTourists || 0;
    openModal('statsModal');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STATS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function loadStats() { try { return JSON.parse(localStorage.getItem('tb_stats')||'{}'); } catch { return {}; } }
function saveStats(s) { localStorage.setItem('tb_stats', JSON.stringify(s)); }
function updateStats(score, tourists) {
    const s = loadStats();
    s.gamesPlayed   = (s.gamesPlayed   || 0) + 1;
    s.bestScore     = Math.max(s.bestScore    || 0, score);
    s.bestTourists  = Math.max(s.bestTourists || 0, tourists);
    s.totalTourists = (s.totalTourists || 0) + tourists;
    saveStats(s); return s;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GESTURES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let ptrStartY=0, ptrActive=false;
document.addEventListener('touchstart', e => { if (!settings.pullToRefresh) return; if (window.scrollY===0) ptrStartY=e.touches[0].clientY; }, {passive:true});
document.addEventListener('touchmove',  e => { if (!settings.pullToRefresh||!ptrStartY) return; if (e.touches[0].clientY-ptrStartY>60) { document.getElementById('ptr-indicator').style.opacity='1'; ptrActive=true; } }, {passive:true});
document.addEventListener('touchend',   () => { if (!settings.pullToRefresh) return; if (ptrActive) { ptrActive=false; document.getElementById('ptr-indicator').style.opacity='0'; location.reload(); } ptrStartY=0; });

let swX=0, swY=0;
document.addEventListener('touchstart', e => { swX=e.touches[0].clientX; swY=e.touches[0].clientY; }, {passive:true});
document.addEventListener('touchend',   e => {
    const dx=e.changedTouches[0].clientX-swX, dy=e.changedTouches[0].clientY-swY;
    if (Math.abs(dx)>60 && Math.abs(dx)>Math.abs(dy)*1.5) { if (dx>0&&swX<40) openMenu(); else closeMenu(); }
    if (dy>80 && Math.abs(dy)>Math.abs(dx)*1.5) ['settingsModal','statsModal','resetModal'].forEach(id => { if (document.getElementById(id).classList.contains('open')) closeModal(id); });
}, {passive:true});

function vibrate(p) { if (settings.vibration && navigator.vibrate) navigator.vibrate(p); }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SERVICE WORKER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('sw.js').then(reg => {
        setInterval(() => reg.update(), 300_000);
        reg.addEventListener('updatefound', () => {
            const sw = reg.installing;
            sw.addEventListener('statechange', () => {
                if (sw.state==='installed' && navigator.serviceWorker.controller) {
                    if (confirm(I18N.updateAvailable.en+'\n'+I18N.updateAvailable.he)) { sw.postMessage({type:'SKIP_WAITING'}); location.reload(); }
                }
            });
        });
    }).catch(e => console.warn('[SW]',e));
}
async function checkRemoteVersion() {
    try { const r=await fetch('./version.json?t='+Date.now()); const d=await r.json(); if (d.version&&d.version!==APP_VERSION) showToast(t('updateAvailable'),'info',8000); } catch {}
}
setTimeout(checkRemoteVersion, 5000); setInterval(checkRemoteVersion, 300_000);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LAZY LOADING (Req 8.1)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
(function initLazyLoading() {
    if (!('IntersectionObserver' in window)) return;
    const obs = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                const el = entry.target;
                if (el.dataset.lazySrc) { el.src = el.dataset.lazySrc; el.removeAttribute('data-lazy-src'); }
                if (el.dataset.lazyBg)  { el.style.backgroundImage = `url(${el.dataset.lazyBg})`; el.removeAttribute('data-lazy-bg'); }
                obs.unobserve(el);
            }
        });
    }, { rootMargin: '100px' });
    document.querySelectorAll('[data-lazy-src],[data-lazy-bg]').forEach(el => obs.observe(el));
})();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SOUND SYSTEM (Req 7.3 â€” sound effects toggle)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const SFX = (() => {
    const ctx = window.AudioContext ? new AudioContext() : null;
    function tone(freq, type, dur, vol=0.3) {
        if (!ctx || !settings.sounds) return;
        if (ctx.state === 'suspended') ctx.resume();
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = type; osc.frequency.value = freq;
        gain.gain.setValueAtTime(vol, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + dur);
        osc.connect(gain); gain.connect(ctx.destination);
        osc.start(); osc.stop(ctx.currentTime + dur);
    }
    return {
        place()    { tone(440, 'sine', 0.12, 0.2); },
        score()    { tone(660, 'sine', 0.1); setTimeout(()=>tone(880,'sine',0.15),80); },
        collapse() { tone(220,'sawtooth',0.5,0.4); setTimeout(()=>tone(110,'sawtooth',0.4,0.3),120); },
        warning()  { tone(330,'square',0.08,0.15); },
    };
})();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// UI STATE PERSISTENCE (Req 7.4 â€” scroll position + UI state)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
(function initUIStatePersistence() {
    // Save difficulty selection
    const savedDiff = localStorage.getItem('tb_ui_difficulty');
    if (savedDiff) {
        document.querySelectorAll('.difficulty-btn').forEach(b => {
            b.classList.toggle('selected', b.dataset.difficulty === savedDiff);
        });
    }
    document.querySelectorAll('.difficulty-btn').forEach(b => {
        b.addEventListener('click', () => localStorage.setItem('tb_ui_difficulty', b.dataset.difficulty));
    });
    // Restore scroll positions on accordions/scroll containers
    const saveScroll = () => {
        try { localStorage.setItem('tb_ui_scroll', JSON.stringify({ top: window.scrollY, left: window.scrollX })); } catch {}
    };
    const restoreScroll = () => {
        try {
            const s = JSON.parse(localStorage.getItem('tb_ui_scroll') || 'null');
            if (s) window.scrollTo(s.left || 0, s.top || 0);
        } catch {}
    };
    window.addEventListener('beforeunload', saveScroll);
    restoreScroll();
})();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// WATCHDOG / ERROR RECOVERY (Req 8.2)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
(function initWatchdog() {
    let lastFrameTime = Date.now();
    let watchdogActive = false;

    function recordFrame() { lastFrameTime = Date.now(); }

    // Expose for Game loop to call
    window._wdTick = recordFrame;

    setInterval(() => {
        if (!watchdogActive) return;
        const stale = Date.now() - lastFrameTime;
        if (stale > 5000) {
            console.warn('[Watchdog] Game loop stalled for', stale, 'ms â€” attempting recovery');
            try {
                if (window.game && typeof game._startLoop === 'function') {
                    game._startLoop();
                    showToast('Watchdog: game loop recovered', 'info', 2000);
                }
            } catch (e) { console.error('[Watchdog] Recovery failed:', e); }
            lastFrameTime = Date.now();
        }
    }, 3000);

    window._watchdogStart = () => { watchdogActive = true; lastFrameTime = Date.now(); };
    window._watchdogStop  = () => { watchdogActive = false; };
})();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PHYSICS ENGINE  â€” clean, verified, single source of truth
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COORDINATE SYSTEM:
//   Tower-local origin = base centre at ground level.
//   x: positive = right,  negative = left   (pixels)
//   y: negative = up,     positive = down    (pixels)
//   Characters are stored in tower-local coords after placement.
//
// TORQUE SIGN CONVENTION:
//   Positive Ï„ â†’ positive Î± â†’ Ï‰ increases â†’ angle increases â†’ tower tilts RIGHT.
//   A character placed at x > 0 (right side) creates positive torque â†’ tilts right. âœ“
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class PhysicsEngine {
    constructor() {
        // All distances in pixels, time in seconds.
        this.COLLAPSE_DEG  = 40;          // game-over tilt angle (degrees)
        this.COLLAPSE_RAD  = this.COLLAPSE_DEG * Math.PI / 180;
        // Semi-implicit Euler params â€” tuned for feel
        this.DAMPING       = 0.993;       // angular velocity decay per frame (calibrated)
        this.OMEGA_MAX     = 2.0;         // rad/s hard cap
        // Spring-damper for elastic micro-flex (visual only)
        this.K_SPRING      = 5.0;
        this.C_SPRING      = 2.0;
        // Sliding friction thresholds (degrees)
        this.MU_STATIC     = 0.45;        // tanÎ¸ threshold for static grip
        this.MU_KINETIC    = 0.28;
        // Wind
        this._windPhase    = Math.random() * 100;
        this.windAmplitude = 0;           // set by difficulty
        this.reset();
    }

    reset() {
        this.angle    = 0;    // Î¸ (rad) â€” authoritative tilt of tower
        this.omega    = 0;    // Ï‰ (rad/s)
        this.pivotX   = 0;    // dynamic contact point (tower-local x)
        // Elastic flex overlay (visual only, not in physics)
        this.flex     = 0;
        this.flexV    = 0;
        // Public readouts
        this.comX     = 0;
        this.comY     = 0;
        this.totalMass= 0;
        this._wind    = 0;
        this._t       = 0;
    }

    // â”€â”€ 1.  Compute COM in tower-local coordinates â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Characters' x and y are already in tower-local space.
    _com(chars) {
        if (!chars.length) { this.comX=0; this.comY=0; this.totalMass=0; return; }
        let M=0, cx=0, cy=0;
        for (const c of chars) { M+=c.mass; cx+=c.mass*c.x; cy+=c.mass*c.y; }
        this.totalMass = M;
        this.comX      = cx/M;   // positive = COM is to the right of tower centre
        this.comY      = cy/M;   // negative = COM is above base
    }

    // â”€â”€ 2.  Dynamic pivot (contact-patch model) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // As long as COM is inside the base footprint the tower rests
    // on its centre â†’ restoring torque.  Once COM passes the edge
    // the tower tips on that edge â†’ no restoring force.
    _pivot(baseWidth) {
        const edge = baseWidth / 2;
        this.pivotX = Math.abs(this.comX) <= edge
            ? 0
            : Math.sign(this.comX) * edge;
    }

    // â”€â”€ 3.  Moment of inertia about the pivot â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // I = I_structure + Î£ m_i Â· r_iÂ²
    // r_i = distance from character to pivot (x dominates rotation)
    _moi(chars) {
        // Structural MOI: calibrated for good gameplay feel.
        // 1 person at far edge (x=30) â†’ collapses in ~7s  (tense, manageable)
        // 1 person at inner slot (x=10) â†’ collapses in ~16s (slow lean)
        // 2 people same side â†’ collapses in ~4-5s
        // Balanced load â†’ stable indefinitely
        const I_struct = 35000;

        let I = I_struct;
        for (const c of chars) {
            const dx = c.x - this.pivotX;  // horizontal lever arm
            const dy = c.y;                 // vertical (contributes less)
            // Pure rotation: rÂ² = dxÂ² + (smaller contribution from dy)
            I += c.mass * (dx*dx + dy*dy*0.05);
        }
        // Parallel-axis shift when pivot is at the edge
        I += this.totalMass * this.pivotX * this.pivotX;
        return I;
    }

    // â”€â”€ 4.  Gravity torque â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Ï„ = (comX - pivotX) Ã— M Ã— g_effective
    //
    // g_effective:  we use pixels/sÂ².
    // A floor is 60px.  Real floor height â‰ˆ 3m.  Scale = 60/3 = 20.
    // g_real = 9.8 m/sÂ²  â†’  g_eff = 9.8 Ã— 20 = 196 px/sÂ²
    // But tower arm is short so we use 150 px/sÂ² for gameplay feel.
    _gravityTorque() {
        const G = 75;    // px/sÂ² â€” calibrated: 1 person on edge â‰ˆ 7s to collapse
        return (this.comX - this.pivotX) * this.totalMass * G;
    }

    // â”€â”€ 5.  Wind torque â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    _updateWind(dt) {
        if (this.windAmplitude === 0) { this._wind=0; return; }
        this._t += dt;
        this._wind = (Math.sin(this._t*0.7)*0.6 + Math.sin(this._t*1.9+1.2)*0.4) * this.windAmplitude;
    }
    _windTorque() {
        // Wind effect scales with tower height (COM y is negative = up)
        const heightFactor = Math.max(0, -this.comY / 300);
        return this._wind * this.totalMass * heightFactor;
    }

    // â”€â”€ 6.  Elastic flex (visual micro-oscillation) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    _updateFlex(dt) {
        const restoring = -this.K_SPRING * this.flex - this.C_SPRING * this.flexV;
        this.flexV += restoring * dt;
        this.flex  += this.flexV  * dt;
        this.flexV *= 0.97;
        this.flex  *= 0.995;
    }

    // â”€â”€ 7.  Impact impulse when character lands â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    applyImpact(char, dropPx, I) {
        // Impulse J = mÂ·v_impact, distributes via lever arm
        const v     = Math.sqrt(2 * 150 * Math.max(dropPx, 20));
        const lever = char.x - this.pivotX;
        const dOmega = (char.mass * v * lever * 0.003) / Math.max(I, 1000);
        this.omega  += dOmega;
        this.flexV  += dOmega * 0.8;   // visual shudder
    }

    // â”€â”€ 8.  Sliding resolution â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    _slide(chars, dt) {
        const sinT = Math.sin(Math.abs(this.angle));
        const cosT = Math.cos(Math.abs(this.angle));
        const dir  = Math.sign(this.angle);
        for (const c of chars) {
            if (sinT > this.MU_STATIC * cosT) {
                c.isSliding = true;
                const a = 150 * (sinT - this.MU_KINETIC * cosT) * 0.002;
                c.vx = (c.vx || 0) + dir * a * dt * 60;
            } else {
                c.isSliding = false;
                c.vx = (c.vx || 0) * 0.8;
            }
            if (c.isSliding) { c.x += c.vx * dt; c.vx *= 0.94; }
        }
    }

    // â”€â”€ 9.  Collapse check â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    _collapsed(baseWidth) {
        if (Math.abs(this.angle) >= this.COLLAPSE_RAD) return true;
        if (Math.abs(this.comX) > baseWidth/2 + 6 && this.totalMass > 0) return true;
        return false;
    }

    // â”€â”€ 10. MAIN STEP â€” called every animation frame â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    step(dt, chars, baseWidth) {
        // Safety: cap dt so a slow frame doesn't explode physics
        dt = Math.min(dt, 0.05);

        // State
        this._com(chars);
        this._pivot(baseWidth);
        const I = this._moi(chars);

        // Accumulate torque
        this._updateWind(dt);
        const tau = this._gravityTorque() + this._windTorque();

        // Semi-Implicit Euler
        //   Ï‰(n+1) = (Ï‰(n) + Î±Â·dt) Ã— damping
        //   Î¸(n+1) = Î¸(n) + Ï‰(n+1)Â·dt
        const alpha = tau / I;
        this.omega += alpha * dt;
        this.omega *= this.DAMPING;
        this.omega  = Math.max(-this.OMEGA_MAX, Math.min(this.OMEGA_MAX, this.omega));
        this.angle += this.omega * dt;
        // NO clamp on angle â€” let it exceed collapse threshold naturally

        // Sub-systems
        this._slide(chars, dt);
        this._updateFlex(dt);

        return this._collapsed(baseWidth);
    }

    // Visual angle = physics angle + elastic flex
    get visualAngle() { return this.angle + this.flex * 0.04; }
    getAngleDeg()     { return this.angle * 180 / Math.PI; }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONFIG
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const CONFIG = {
    tower: { baseWidth:80, floorHeight:60, floorCount:8, maxPerFloor:4 },
    chars: {
        standard: { mass:1.0, size:20, icon:'ğŸ§', color:'#4a9eff', label:'hudCharNormal' },
        heavy:    { mass:2.5, size:26, icon:'ğŸ‹ï¸', color:'#ff4a4a', label:'hudCharHeavy'  },
        child:    { mass:0.5, size:15, icon:'ğŸ‘¶', color:'#ffd700', label:'hudCharLight'  },
    },
    difficulty: {
        easy:   { timer:false, wind:false,  friction:0.8 },
        medium: { timer:true,  timerDur:15, wind:false,  windAmp:0   },
        hard:   { timer:true,  timerDur:10, wind:true,   windAmp:60  },
        expert: { timer:true,  timerDur:8,  wind:true,   windAmp:130 },
    },
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CHARACTER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class Character {
    constructor(type, x, y) {
        const cfg = CONFIG.chars[type];
        this.type = type; this.mass = cfg.mass; this.size = cfg.size;
        this.icon = cfg.icon; this.color = cfg.color;
        this.x = x; this.y = y;  // tower-local after placement
        this.isSliding = false; this.vx = 0;
    }
    draw(ctx) {
        ctx.save(); ctx.translate(this.x, this.y);
        // Shadow
        ctx.shadowColor = 'rgba(0,0,0,0.3)'; ctx.shadowBlur = 8;
        ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(0,0,this.size,0,Math.PI*2); ctx.fill();
        ctx.shadowBlur = 0;
        ctx.font = `${this.size*1.3}px Arial`; ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.fillText(this.icon, 0, 1);
        ctx.restore();
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TOWER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class Tower {
    constructor(canvas) {
        this.canvas = canvas;
        this.baseX = canvas.width / 2;
        this.baseY = canvas.height - 120;
        this.floors = [];
        this._init();
    }
    _init() {
        this.floors = [];
        for (let i = 0; i < CONFIG.tower.floorCount; i++) {
            // tower-local y: floor 0 = lowest, floor 7 = highest
            // y is negative (above base), so floor i centre is at y = -(i+0.5)*floorHeight
            const floorY = -(i + 1) * CONFIG.tower.floorHeight;
            this.floors.push({ y: floorY, chars: [] });
        }
    }
    reset() { this.floors.forEach(f => f.chars = []); }

    // Place character's x,y in tower-local space
    // x: spread evenly within baseWidth, y: floor surface y
    addChar(char, floorIdx) {
        if (floorIdx < 0 || floorIdx >= this.floors.length) return false;
        const fl = this.floors[floorIdx];
        if (fl.chars.length >= CONFIG.tower.maxPerFloor) fl.chars.shift();
        // x position: spread characters evenly across floor width
        const slot  = fl.chars.length;              // 0..3
        const slots = CONFIG.tower.maxPerFloor;
        const step  = CONFIG.tower.baseWidth / slots;
        char.x = -CONFIG.tower.baseWidth/2 + step*(slot+0.5);
        char.y = fl.y;                               // tower-local y = floor surface
        char.vx = 0;
        fl.chars.push(char);
        return true;
    }

    allChars() { return this.floors.flatMap(f => f.chars); }

    draw(ctx, angle, comX, showCOM) {
        const BW = CONFIG.tower.baseWidth;
        const FH = CONFIG.tower.floorHeight;
        const FC = CONFIG.tower.floorCount;

        ctx.save();
        ctx.translate(this.baseX, this.baseY);
        ctx.rotate(angle);

        // Base platform
        const baseGrad = ctx.createLinearGradient(-BW/2, 0, BW/2, 20);
        baseGrad.addColorStop(0,'#ff6b35'); baseGrad.addColorStop(1,'#f7931e');
        ctx.fillStyle = baseGrad;
        this._roundRect(ctx, -BW/2-4, 0, BW+8, 22, 6);
        ctx.fill();

        // Support columns
        const colW = 10;
        [-BW/2+4, BW/2-colW-4].forEach(colX => {
            const colGrad = ctx.createLinearGradient(0,0,0,-FC*FH);
            colGrad.addColorStop(0,'#8892b0'); colGrad.addColorStop(1,'#445577');
            ctx.fillStyle = colGrad;
            ctx.fillRect(colX, -FC*FH, colW, FC*FH);
        });

        // Floors
        this.floors.forEach((fl, i) => {
            const fy = fl.y;
            // Floor slab
            const flGrad = ctx.createLinearGradient(-BW/2, fy, BW/2, fy);
            flGrad.addColorStop(0,'#f7931e'); flGrad.addColorStop(0.5,'#ffaa55'); flGrad.addColorStop(1,'#f7931e');
            ctx.fillStyle = flGrad;
            ctx.fillRect(-BW/2+10, fy, BW-20, 10);
            // Cyan outline
            ctx.strokeStyle = 'rgba(0,217,255,0.6)'; ctx.lineWidth = 1.5;
            ctx.strokeRect(-BW/2+10, fy, BW-20, 10);
            // Floor number
            ctx.fillStyle = 'rgba(0,217,255,0.4)'; ctx.font='9px Orbitron'; ctx.textAlign='right';
            ctx.fillText(i+1, BW/2-14, fy+9);
        });

        // COM indicator
        if (showCOM && this.allChars().length > 0) {
            ctx.beginPath();
            ctx.arc(comX, 0, 7, 0, Math.PI*2);
            ctx.fillStyle = Math.abs(comX) > BW/2 ? 'rgba(255,51,102,0.9)' : 'rgba(0,217,255,0.9)';
            ctx.fill();
            ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();
            // Vertical line from COM to base
            ctx.beginPath();
            ctx.setLineDash([3,3]);
            ctx.moveTo(comX, 0); ctx.lineTo(comX, -20);
            ctx.strokeStyle = 'rgba(0,217,255,0.5)'; ctx.lineWidth = 1; ctx.stroke();
            ctx.setLineDash([]);
        }

        ctx.restore();
    }

    _roundRect(ctx, x, y, w, h, r) {
        ctx.beginPath(); ctx.moveTo(x+r,y);
        ctx.lineTo(x+w-r,y); ctx.arcTo(x+w,y,x+w,y+r,r);
        ctx.lineTo(x+w,y+h-r); ctx.arcTo(x+w,y+h,x+w-r,y+h,r);
        ctx.lineTo(x+r,y+h); ctx.arcTo(x,y+h,x,y+h-r,r);
        ctx.lineTo(x,y+r); ctx.arcTo(x,y,x+r,y,r);
        ctx.closePath();
    }

    // World-space y of a floor surface (used for drop detection)
    floorWorldY(fi) { return this.baseY + this.floors[fi].y; }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CAMERA
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class Camera {
    constructor() { this.mode = 'default'; this.zoom = 1; this.offsetX = 0; this.offsetY = 0; }

    apply(ctx, canvas, towerBaseX, towerBaseY) {
        if (this.mode === 'default') return;
        if (this.mode === 'top') {
            // Bird's-eye: pivot around tower base, flatten vertically
            ctx.translate(towerBaseX, towerBaseY);
            ctx.scale(1.2, 0.28);
            ctx.translate(-towerBaseX, -towerBaseY);
        } else if (this.mode === 'horizon') {
            // Fit entire tower into view with zoom
            const towerTopY = towerBaseY - CONFIG.tower.floorCount * CONFIG.tower.floorHeight;
            const towerMidY = (towerBaseY + towerTopY) / 2;
            const sceneH    = towerBaseY - towerTopY + 80;
            const scale     = Math.min(canvas.height * 0.82 / sceneH, 2.0);
            ctx.translate(canvas.width / 2, canvas.height * 0.55);
            ctx.scale(scale, scale);
            ctx.translate(-canvas.width / 2, -towerMidY);
        }
    }

    setMode(mode, btns) {
        this.mode = mode;
        btns.forEach(b => b.classList.remove('active'));
        const map = { default:'defaultViewBtn', top:'topViewBtn', horizon:'horizonBtn' };
        const el = document.getElementById(map[mode]);
        if (el) el.classList.add('active');
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GAME
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx    = this.canvas.getContext('2d');
        this._resize();

        this.physics  = new PhysicsEngine();
        this.tower    = new Tower(this.canvas);
        this.camera   = new Camera();

        this.diff     = 'medium';
        this.score    = 0;
        this.turn     = 1;
        this.tourists = 0;
        this.maxAngle = 0;
        this.over     = false;

        this.nextType = this._rndType();
        this.drag     = null;   // Character being dragged
        this.ghost    = null;   // ghost preview { x, y, fi, valid }

        this.timer    = 0;
        this.loop_ts  = null;
        this._running = false;

        this._setupEvents();
        window.addEventListener('resize', () => {
            this._resize();
            this.tower.baseX = this.canvas.width / 2;
            this.tower.baseY = this.canvas.height - 120;
        });
    }

    _resize() { this.canvas.width = window.innerWidth; this.canvas.height = window.innerHeight; }

    _setupEvents() {
        const c = this.canvas;
        c.addEventListener('mousedown',  e => this._startDrag(e.clientX, e.clientY));
        c.addEventListener('mousemove',  e => this._moveDrag(e.clientX, e.clientY));
        c.addEventListener('mouseup',    e => this._endDrag(e.clientX, e.clientY));
        c.addEventListener('touchstart', e => { e.preventDefault(); this._startDrag(e.touches[0].clientX, e.touches[0].clientY); }, {passive:false});
        c.addEventListener('touchmove',  e => { e.preventDefault(); this._moveDrag(e.touches[0].clientX, e.touches[0].clientY); }, {passive:false});
        c.addEventListener('touchend',   e => { e.preventDefault(); const t=e.changedTouches[0]; this._endDrag(t.clientX, t.clientY); }, {passive:false});

        const cBtns = document.querySelectorAll('.control-btn');
        document.getElementById('defaultViewBtn').addEventListener('click', () => this.camera.setMode('default', cBtns));
        document.getElementById('topViewBtn').addEventListener('click',     () => this.camera.setMode('top',     cBtns));
        document.getElementById('horizonBtn').addEventListener('click',     () => this.camera.setMode('horizon', cBtns));
    }

    _startDrag(cx, cy) {
        if (this.over || this.drag) return;
        const r = this.canvas.getBoundingClientRect();
        const x = cx - r.left, y = cy - r.top;
        this.drag = new Character(this.nextType, x, y);
        this.drag._startY = y;
        vibrate(12);
    }

    _moveDrag(cx, cy) {
        if (!this.drag) return;
        const r = this.canvas.getBoundingClientRect();
        this.drag.x = cx - r.left;
        this.drag.y = cy - r.top;
        this._updateGhost(this.drag.x, this.drag.y);
    }

    _endDrag(cx, cy) {
        if (!this.drag) return;
        const r  = this.canvas.getBoundingClientRect();
        const mx = cx - r.left, my = cy - r.top;
        const fi = this._floorAt(my);

        if (fi >= 0) {
            const dropPx = Math.max(0, (this.drag._startY||my) - this.tower.floorWorldY(fi));
            this.tower.addChar(this.drag, fi);
            // Recompute I with all characters now including the new one
            const allC = this.tower.allChars();
            this.physics._com(allC);
            this.physics._pivot(CONFIG.tower.baseWidth);
            const I = this.physics._moi(allC);
            this.physics.applyImpact(this.drag, dropPx, I);
            this.score    += Math.round(this.drag.mass * 10);
            this.tourists++;
            this.turn++;
            this.timer = 0;
            this.nextType = this._rndType();
            this._updateHUD();
            this._updateNextChar();
            this._save();
            vibrate(22);
            SFX.place();
            if (this.score > 0 && this.score % 50 === 0) SFX.score();
        } else {
            vibrate([40,20,40]);
        }
        this.drag  = null;
        this.ghost = null;
    }

    _updateGhost(wx, wy) {
        const fi = this._floorAt(wy);
        if (fi < 0) { this.ghost = null; return; }
        const fl = this.tower.floors[fi];
        this.ghost = {
            worldY: this.tower.floorWorldY(fi),
            fi,
            valid: fl.chars.length < CONFIG.tower.maxPerFloor,
        };
    }

    _floorAt(worldY) {
        for (let i = 0; i < this.tower.floors.length; i++) {
            if (Math.abs(worldY - this.tower.floorWorldY(i)) < 44) return i;
        }
        return -1;
    }

    _rndType() {
        if (this.turn % 6 === 0) return 'heavy';
        return Math.random() < 0.2 ? 'child' : 'standard';
    }

    start(diff) {
        this.diff     = diff;
        this.score    = 0; this.turn = 1; this.tourists = 0; this.maxAngle = 0; this.over = false;
        this.timer    = 0; this.loop_ts = null; this._wasDanger = false;
        this.physics.reset();
        this.tower.reset();
        this.tower.baseX = this.canvas.width  / 2;
        this.tower.baseY = this.canvas.height - 120;

        const dc = CONFIG.difficulty[diff];
        this.physics.windAmplitude = dc.windAmp || 0;
        document.getElementById('timerContainer').style.display = dc.timer ? 'block' : 'none';

        this.nextType = this._rndType();
        this._updateHUD();
        this._updateNextChar();

        if (!this._running) {
            this._running = true;
            this._startLoop();
        }
        if (window._watchdogStart) window._watchdogStart();
    }

    _startLoop() {
        this.loop_ts = null;
        requestAnimationFrame(ts => this._tick(ts));
    }

    _tick(ts) {
        if (!this.loop_ts) this.loop_ts = ts;
        const dt = Math.min((ts - this.loop_ts) / 1000, 0.05);
        this.loop_ts = ts;
        if (window._wdTick) window._wdTick();   // watchdog heartbeat

        if (!this.over) {
            const dc = CONFIG.difficulty[this.diff];
            if (dc.timer) {
                this.timer += dt;
                const pct = Math.max(0, 1 - this.timer / dc.timerDur);
                document.getElementById('timerBar').style.width = (pct*100) + '%';
                if (this.timer >= dc.timerDur) { this._forceSpawn(); this.timer = 0; }
            }

            const chars = this.tower.allChars();
            const collapsed = this.physics.step(dt, chars, CONFIG.tower.baseWidth);
            const deg = Math.abs(this.physics.getAngleDeg());
            if (deg > this.maxAngle) this.maxAngle = deg;
            this._updateStability();

            // Danger tilt visual flash + sound warning
            const wasDanger = this._wasDanger;
            const isDanger  = deg > 25;
            document.body.classList.toggle('danger-tilt', isDanger);
            if (isDanger && !wasDanger) SFX.warning();
            this._wasDanger = isDanger;

            if (collapsed) { SFX.collapse(); this._gameOver(); }
        }

        this._draw();
        requestAnimationFrame(ts2 => this._tick(ts2));
    }

    _forceSpawn() {
        const fi   = Math.floor(Math.random() * this.tower.floors.length);
        const char = new Character(this._rndType(), 0, 0);
        this.tower.addChar(char, fi);
        this.tourists++; this.turn++;
        this.nextType = this._rndType();
        this._updateHUD(); this._updateNextChar();
    }

    _draw() {
        const ctx = this.ctx;
        const W = this.canvas.width, H = this.canvas.height;
        ctx.clearRect(0, 0, W, H);

        // â”€â”€ Ground â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        const groundY = this.tower.baseY + 22;
        const groundGrad = ctx.createLinearGradient(0, groundY, 0, groundY + 40);
        groundGrad.addColorStop(0, settings.darkMode ? 'rgba(136,146,176,0.3)' : 'rgba(100,120,160,0.25)');
        groundGrad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = groundGrad;
        ctx.fillRect(0, groundY, W, 40);
        ctx.strokeStyle = settings.darkMode ? 'rgba(136,146,176,0.5)' : 'rgba(100,120,160,0.4)';
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(0, groundY); ctx.lineTo(W, groundY); ctx.stroke();

        ctx.save();

        // Apply camera transform
        this.camera.apply(ctx, this.canvas, this.tower.baseX, this.tower.baseY);

        // â”€â”€ Tower shadow (shows tilt direction clearly) â”€â”€â”€â”€â”€â”€â”€â”€
        const angleDeg = this.physics.getAngleDeg();
        const shadowLen = CONFIG.tower.floorCount * CONFIG.tower.floorHeight;
        const shadowX = Math.sin(this.physics.visualAngle) * shadowLen;
        const shadowGrad = ctx.createLinearGradient(
            this.tower.baseX, groundY,
            this.tower.baseX + shadowX * 0.8, groundY
        );
        shadowGrad.addColorStop(0, 'rgba(0,0,0,0.18)');
        shadowGrad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.save();
        ctx.beginPath();
        ctx.ellipse(
            this.tower.baseX + shadowX * 0.4,
            groundY + 6,
            Math.max(20, Math.abs(shadowX) * 0.5 + 30), 10,
            0, 0, Math.PI * 2
        );
        ctx.fillStyle = 'rgba(0,0,0,0.12)';
        ctx.fill();
        ctx.restore();

        // Draw tower structure + COM indicator
        const showCOM = true;
        this.tower.draw(ctx, this.physics.visualAngle, this.physics.comX, showCOM);

        // Draw characters (in tower-local rotating frame)
        ctx.save();
        ctx.translate(this.tower.baseX, this.tower.baseY);
        ctx.rotate(this.physics.visualAngle);
        this.tower.allChars().forEach(c => c.draw(ctx));
        ctx.restore();

        // â”€â”€ Tilt angle arc indicator (at tower base) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        if (Math.abs(this.physics.angle) > 0.01) {
            ctx.save();
            ctx.translate(this.tower.baseX, this.tower.baseY);
            const arcR = 44;
            const danger = Math.abs(angleDeg) > 25;
            ctx.strokeStyle = danger ? 'rgba(255,51,102,0.85)' : 'rgba(255,107,53,0.7)';
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.arc(0, 0, arcR, -Math.PI/2, -Math.PI/2 + this.physics.angle, this.physics.angle > 0);
            ctx.stroke();
            // Angle label
            ctx.fillStyle = danger ? '#ff3366' : '#ff6b35';
            ctx.font = 'bold 11px Orbitron, monospace';
            ctx.textAlign = 'center';
            const labelAngle = this.physics.angle / 2 - Math.PI/2;
            ctx.fillText(
                Math.abs(angleDeg).toFixed(1) + 'Â°',
                Math.cos(labelAngle) * (arcR + 14),
                Math.sin(labelAngle) * (arcR + 14)
            );
            ctx.restore();
        }

        // Ghost drop preview (world space, no rotation)
        if (this.ghost) {
            ctx.save();
            const gx = this.drag ? this.drag.x : this.tower.baseX;
            const gy = this.ghost.worldY;
            ctx.globalAlpha = 0.55;
            if (this.ghost.valid) {
                ctx.fillStyle = 'rgba(0,255,163,0.35)';
                ctx.strokeStyle = '#00ffa3';
            } else {
                ctx.fillStyle = 'rgba(255,51,102,0.3)';
                ctx.strokeStyle = '#ff3366';
            }
            ctx.lineWidth = 2;
            ctx.beginPath(); ctx.arc(gx, gy, CONFIG.chars[this.nextType].size, 0, Math.PI*2);
            ctx.fill(); ctx.stroke();
            if (this.drag) {
                ctx.beginPath(); ctx.setLineDash([5,5]);
                ctx.moveTo(gx, this.drag.y); ctx.lineTo(gx, gy);
                ctx.strokeStyle = this.ghost.valid ? '#00ffa3' : '#ff3366';
                ctx.lineWidth = 1.5; ctx.stroke(); ctx.setLineDash([]);
            }
            ctx.restore();
        }

        // Dragged character (world space)
        if (this.drag) this.drag.draw(ctx);

        ctx.restore();
    }

    _updateHUD() {
        document.getElementById('scoreDisplay').textContent   = this.score;
        document.getElementById('turnDisplay').textContent    = this.turn;
        document.getElementById('touristDisplay').textContent = this.tourists;
    }

    _updateNextChar() {
        const cfg = CONFIG.chars[this.nextType];
        document.getElementById('nextIcon').textContent = cfg.icon;
        document.getElementById('nextType').textContent = t(cfg.label);
    }

    _updateStability() {
        // Needle moves left/right relative to collapse angle
        const pct = (this.physics.angle / this.physics.COLLAPSE_RAD) * 50 + 50;
        const clamped = Math.max(4, Math.min(96, pct));
        const needle = document.getElementById('stabilityNeedle');
        needle.style.left = clamped + '%';
        const deg = Math.abs(this.physics.getAngleDeg());
        needle.style.background =
            deg > 28 ? 'var(--danger)' :
            deg > 15 ? 'var(--secondary)' :
            'var(--success)';
        needle.style.boxShadow = deg > 28
            ? '0 0 12px rgba(255,51,102,.8)'
            : '0 0 8px rgba(0,255,163,.6)';
    }

    _save() {
        localStorage.setItem('tb_gamestate', JSON.stringify({
            score:this.score, turn:this.turn, tourists:this.tourists,
            maxAngle:this.maxAngle, diff:this.diff, ts:Date.now()
        }));
    }

    _gameOver() {
        this.over = true;
        document.body.classList.remove('danger-tilt');
        const stats = updateStats(this.score, this.tourists);
        document.getElementById('finalScore').textContent    = this.score;
        document.getElementById('finalTourists').textContent = this.tourists;
        document.getElementById('finalAngle').textContent    = this.maxAngle.toFixed(1) + 'Â°';
        const isHS = this.score >= stats.bestScore;
        document.getElementById('newHighScoreMsg').textContent = isHS ? t('newHighScore') : '';
        document.getElementById('bestScoreDisplay').textContent = stats.bestScore;
        document.getElementById('gameOverScreen').style.display = 'flex';
        vibrate([200,100,200]);
        localStorage.removeItem('tb_gamestate');
    }

    updateNextCharDisplay() { this._updateNextChar(); }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BOOT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let game;
document.getElementById('bestScoreDisplay').textContent = loadStats().bestScore || 0;

document.getElementById('startBtn').addEventListener('click', () => {
    const diff = document.querySelector('.difficulty-btn.selected').dataset.difficulty;
    if (!game) game = new Game();
    game.start(diff);
    document.getElementById('startScreen').style.display    = 'none';
    document.getElementById('gameOverScreen').style.display = 'none';
    vibrate(30);
});

document.getElementById('restartBtn').addEventListener('click', () => {
    const diff = document.querySelector('.difficulty-btn.selected').dataset.difficulty;
    document.getElementById('gameOverScreen').style.display = 'none';
    game.start(diff);
    vibrate(30);
});

document.querySelectorAll('.difficulty-btn').forEach(btn => {
    btn.addEventListener('click', () => {
        document.querySelectorAll('.difficulty-btn').forEach(b => b.classList.remove('selected'));
        btn.classList.add('selected');
    });
});

function updateNextCharDisplay() { if (game) game.updateNextCharDisplay(); }

initSettings();
</script>
</body>
</html>
